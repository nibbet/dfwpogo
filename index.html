<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFW Pokemon GO</title>
    <!-- PWA: manifest and theme color -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6E46A6">
    <link rel="apple-touch-icon" href="img/apple-touch-icon.png">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="DFW PoGO">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <link rel="stylesheet" href="css/styles.css">
    <script>
        // Use marked defaults and enable GFM + line breaks
        marked.setOptions({
            gfm: true,
            breaks: true
        });

        // No collapsible behavior ‚Äî headers will be static purple sections
    </script>
</head>
<body>
    <div class="header">
        <h1>DFW Pok√©mon Go</h1>
        <p>Your guide to local community events and Campfire groups</p>
    </div>

    <div class="container">
        <div class="nav-container">
            <button class="mobile-nav-toggle" onclick="toggleMobileNav()">
                <span class="current-tab">üìÖ Events</span>
                <span class="hamburger">‚ò∞</span>
            </button>
            <div class="nav-tabs" id="nav-tabs">
                <button class="tab-btn active" onclick="showTab('events', 'üìÖ Pok√©mon Go Events')">üìÖ Pok√©mon Go Events</button>
                <button id="signature-tab-btn" class="tab-btn" onclick="showTab('signature', 'üåü Signature Events')">üåü Signature Events</button>
                <button class="tab-btn" onclick="showTab('campfire', 'üî• Campfire Groups')">üî• Campfire Groups</button>
            </div>
        </div>

        <div class="content-area">
            <div id="events-tab" class="tab-content">
                <h2>Upcoming Events</h2>
                <div id="events-list" class="event-grid">
                    <div class="loading">Loading events...</div>
                </div>
            </div>

            <div id="signature-tab" class="tab-content" style="display:none;">
                <div id="signature-content" class="markdown-content">
                    <div class="loading">Loading signature event...</div>
                </div>
            </div>

            <div id="campfire-tab" class="tab-content" style="display:none;">
                <h2>Local Campfire Groups</h2>
                <div id="campfire-list">
                    <div class="loading">Loading Campfire groups...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add to Home Screen Banner -->
    <div id="install-banner" class="install-banner" style="display: none;">
        <div class="install-banner-content">
            <div class="install-banner-text">
                <strong>üì± Install DFW PoGO</strong>
                <p>Add to your home screen for quick access!</p>
            </div>
            <div class="install-banner-actions">
                <button id="install-button" class="install-btn">Install</button>
                <button id="install-dismiss" class="install-dismiss">‚úï</button>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // MAINTENANCE MODE - Change to true to enable
        // ==========================================
        const MAINTENANCE_MODE = false;
        
        let eventsData = [];
        let campfireData = '';
        let signatureData = '';
        let signatureTitle = localStorage.getItem('lastSignatureTitle') || 'Signature Events';

        // Constants for localStorage
        const STORAGE_KEYS = {
            TITLE: 'lastSignatureTitle',
            LAST_UPDATED: 'signatureTitleLastUpdated'
        };

        // Cache duration (24 hours in milliseconds)
        const CACHE_DURATION = 24 * 60 * 60 * 1000;

        // Load markdown files from GitHub
        async function loadMarkdownFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}`);
                }
                return await response.text();
            } catch (error) {
                console.error(`Error loading ${filename}:`, error);
                return null;
            }
        }

        // Parse events and filter out past events
        function parseEvents(markdown) {
            if (!markdown) return [];
            const events = [];
            const sections = markdown.split('##').filter(s => s.trim());
            const today = new Date();
            sections.forEach(section => {
                const lines = section.trim().split('\n');
                const title = lines[0].trim();
                const content = lines.slice(1).join('\n');
                const dateMatch = content.match(/\*\*Date:\*\*\s*(.+)/);
                const pokemonMatch = content.match(/\*\*Featured Pokemon:\*\*\s*(.+)/);
                const typeMatch = content.match(/\*\*Type:\*\*\s*(.+)/);
                const timeMatch = content.match(/\*\*Time\*\*\s*:?\s*(.+)/);
                let cleanContent = content
                    .replace(/\*\*Date:\*\*[^\n]*\n?/g, '')
                    .replace(/\*\*Featured Pokemon:\*\*[^\n]*\n?/g, '')
                    .replace(/\*\*Type:\*\*[^\n]*\n?/g, '')
                    .replace(/\*\*Time\*\*\s*:?.*\n?/g, '')
                    .trim();
                // Parse the date for filtering
                let eventDate = null;
                if (dateMatch) {
                    let dateStr = dateMatch[1].split(/[‚Äì-]/)[0].trim();
                    if (!/\d{4}/.test(dateStr) && /\d{4}/.test(dateMatch[1])) {
                        dateStr += ', ' + dateMatch[1].match(/\d{4}/)[0];
                    }
                    eventDate = new Date(dateStr);
                }
                let isUpcoming = true;
                if (eventDate instanceof Date && !isNaN(eventDate)) {
                    const eventDay = new Date(eventDate.getFullYear(), eventDate.getMonth(), eventDate.getDate());
                    const todayDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                    isUpcoming = eventDay >= todayDay;
                }
                if (isUpcoming) {
                    events.push({
                        title,
                        date: dateMatch ? dateMatch[1].trim() : 'TBA',
                        time: timeMatch ? timeMatch[1].trim() : '',
                        pokemon: pokemonMatch ? pokemonMatch[1].trim() : '',
                        type: typeMatch ? typeMatch[1].trim().toLowerCase().replace(/\s+/g, '-') : 'event',
                        content: marked.parse(cleanContent)
                    });
                }
            });
            return events;
        }

        function parseSignatureEvent(markdown) {
            if (!markdown || !markdown.trim()) {
                hideSignatureTab();
                return '';
            }
            
            // Extract title from first h1
            const titleMatch = markdown.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                const newTitle = titleMatch[1].trim();
                updateSignatureTitle(newTitle);
                showSignatureTab();
            } else {
                // Try to use cached title if available and not expired
                const cachedTitle = getCachedTitle();
                if (cachedTitle) {
                    signatureTitle = cachedTitle;
                    updateSignatureTabLabel();
                    showSignatureTab();
                } else {
                    hideSignatureTab();
                }
            }
            return marked.parse(markdown);
        }

        function updateSignatureTitle(newTitle) {
            signatureTitle = newTitle;
            // Cache the new title
            localStorage.setItem(STORAGE_KEYS.TITLE, newTitle);
            localStorage.setItem(STORAGE_KEYS.LAST_UPDATED, Date.now().toString());
            updateSignatureTabLabel();
        }

        function getCachedTitle() {
            const lastUpdated = parseInt(localStorage.getItem(STORAGE_KEYS.LAST_UPDATED) || '0');
            const cachedTitle = localStorage.getItem(STORAGE_KEYS.TITLE);
            
            // Check if cache exists and isn't expired
            if (cachedTitle && Date.now() - lastUpdated < CACHE_DURATION) {
                return cachedTitle;
            }
            
            // Clear expired cache
            localStorage.removeItem(STORAGE_KEYS.TITLE);
            localStorage.removeItem(STORAGE_KEYS.LAST_UPDATED);
            return null;
        }

        function updateSignatureTabLabel() {
            const tabBtn = document.getElementById('signature-tab-btn');
            if (!tabBtn) return;
            
            // Shorten title if it's too long
            const displayTitle = signatureTitle.length > 25 
                ? signatureTitle.substring(0, 22) + '...' 
                : signatureTitle;
            tabBtn.innerHTML = `üåü ${displayTitle}`;
            tabBtn.setAttribute('onclick', `showTab('signature', 'üåü ${displayTitle}')`);
        }

        function hideSignatureTab() {
            const tabBtn = document.getElementById('signature-tab-btn');
            if (tabBtn) {
                tabBtn.classList.add('hiding');
                // Wait for transition before hiding
                setTimeout(() => {
                    // If we previously moved the tab, attempt to restore its original position
                    const navTabs = document.getElementById('nav-tabs');
                    if (tabBtn.dataset && tabBtn.dataset.originalIndex) {
                        const originalIndex = parseInt(tabBtn.dataset.originalIndex, 10);
                        // If originalIndex is within bounds, insert before that child, otherwise append
                        if (!isNaN(originalIndex) && originalIndex < navTabs.children.length) {
                            navTabs.insertBefore(tabBtn, navTabs.children[originalIndex]);
                        } else {
                            navTabs.appendChild(tabBtn);
                        }
                        delete tabBtn.dataset.originalIndex;
                    }

                    tabBtn.style.display = 'none';
                    tabBtn.classList.remove('hiding');
                    // If signature tab was active, switch to events tab
                    if (tabBtn.classList.contains('active')) {
                        showTab('events', 'üìÖ Events');
                    }
                }, 300); // Match transition duration
            }
            const signatureTab = document.getElementById('signature-tab');
            if (signatureTab) {
                signatureTab.style.display = 'none';
            }
        }

        function showSignatureTab() {
            const tabBtn = document.getElementById('signature-tab-btn');
            if (tabBtn) {
                // Move the signature tab to the front when visible, remembering original position
                const navTabs = document.getElementById('nav-tabs');
                if (navTabs && !tabBtn.dataset.originalIndex) {
                    const children = Array.from(navTabs.children);
                    const idx = children.indexOf(tabBtn);
                    if (idx !== -1) tabBtn.dataset.originalIndex = idx;
                    navTabs.insertBefore(tabBtn, navTabs.firstChild);
                }

                // Reset visibility without transition
                tabBtn.classList.remove('hiding');
                tabBtn.style.opacity = '0';
                tabBtn.style.display = '';

                // Trigger transition
                requestAnimationFrame(() => {
                    tabBtn.style.opacity = '1';
                });
            }
        }

        function renderEvents() {
            const container = document.getElementById('events-list');
            
            if (eventsData.length === 0) {
                container.innerHTML = '<div class="error">No events found. Please ensure events.md exists in your repository.</div>';
                return;
            }
            
            container.innerHTML = eventsData.map(event => {
                // event.content comes pre-parsed (HTML) and metadata lines were removed in parseEvents
                const processedContent = event.content;
                const timeDisplay = event.time ? `<p><strong>üïí ${event.time}</strong></p>` : '';

                return `
                <div class="event-card">
                    <span class="event-type type-${event.type}">${event.type.replace(/-/g, ' ').toUpperCase()}</span>
                    <h3>${event.title}</h3>
                    <p><strong>üìÖ ${event.date}</strong></p>
                    ${timeDisplay}
                    ${event.pokemon ? `<p><strong>‚ö° Featured: ${event.pokemon}</strong></p>` : ''}
                    <div class="markdown-content">${processedContent}</div>
                </div>
                `;
            }).join('');
        }

        function renderSignature() {
            const container = document.getElementById('signature-content');

            if (!signatureData) {
                container.innerHTML = '<div class="error">No signature event found. Please ensure signature.md exists in your repository.</div>';
                return;
            }

            // Parse the pre-rendered HTML from marked
            const temp = document.createElement('div');
            temp.innerHTML = signatureData;

            // Extract title from H1
            const h1 = temp.querySelector('h1');
            const titleText = h1 ? h1.textContent.trim() : 'Signature Event';
            if (h1) h1.remove();

            // Extract the first H2 section for metadata
            const firstH2 = temp.querySelector('h2');
            let metaContent = null;
            if (firstH2 && firstH2.textContent.includes('Overview')) {
                // Get all content between first H2 and second H2
                metaContent = document.createElement('div');
                let node = firstH2.nextSibling;
                const secondH2 = Array.from(temp.querySelectorAll('h2'))[1];
                while (node && node !== secondH2) {
                    const next = node.nextSibling;
                    if (node.nodeType === 1 || (node.nodeType === 3 && node.textContent.trim())) {
                        metaContent.appendChild(node.cloneNode(true));
                    }
                    node = next;
                }
                firstH2.remove();
            }

            // Build the card
            container.innerHTML = '';
            
            // Create header card with title and overview
            const headerCard = document.createElement('div');
            headerCard.className = 'signature-card signature-header-card';
            
            const title = document.createElement('h1');
            title.textContent = titleText;
            headerCard.appendChild(title);
            
            if (metaContent && metaContent.innerHTML.trim()) {
                const overview = document.createElement('div');
                overview.className = 'signature-overview';
                overview.innerHTML = metaContent.innerHTML;
                headerCard.appendChild(overview);
            }
            
            container.appendChild(headerCard);

            // Process remaining H2 sections as individual cards
            const allH2s = Array.from(temp.querySelectorAll('h2'));
            
            allH2s.forEach((h2) => {
                const sectionCard = document.createElement('div');
                sectionCard.className = 'event-card signature-section-card';
                
                // Add section title
                const sectionTitle = document.createElement('h2');
                sectionTitle.innerHTML = h2.innerHTML;
                sectionCard.appendChild(sectionTitle);
                
                // Collect content until next H2
                const content = document.createElement('div');
                content.className = 'markdown-content';
                
                let node = h2.nextSibling;
                const nextH2 = allH2s[allH2s.indexOf(h2) + 1];
                while (node && node !== nextH2) {
                    const next = node.nextSibling;
                    if (node.nodeType === 1 || (node.nodeType === 3 && node.textContent.trim())) {
                        content.appendChild(node.cloneNode(true));
                    }
                    node = next;
                }
                
                sectionCard.appendChild(content);
                container.appendChild(sectionCard);
            });
        }

            
        function renderCampfire() {
            const container = document.getElementById('campfire-list');
            
            console.log('renderCampfire called, campfireData:', campfireData ? `${campfireData.length} chars` : 'null');
            
            if (!campfireData) {
                container.innerHTML = '<div class="error">No Campfire groups found. Please ensure campfire.md exists in your repository.</div>';
                return;
            }

            // Parse campfire markdown - format uses ### headers and bullet points
            const groups = [];
            const lines = campfireData.split('\n');
            console.log('Total lines in campfire.md:', lines.length);
            
            let currentGroup = null;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check for H3 header (### Group Name)
                const headerMatch = line.match(/^###\s+(.+)$/);
                if (headerMatch) {
                    if (currentGroup) {
                        groups.push(currentGroup);
                    }
                    currentGroup = {
                        name: headerMatch[1].trim(),
                        link: null,
                        ambassador: null
                    };
                    continue;
                }
                
                // Check for link in various formats:
                // Direct: [Join Group](url)
                // Bullet: - **Link:** [Join Group](url)
                const linkMatch = line.match(/\[Join Group\]\((.+?)\)/);
                if (linkMatch && currentGroup) {
                    currentGroup.link = linkMatch[1].trim();
                }

                // Check for ambassador led line: - **Ambassador Led:** ‚úÖ Yes or ‚ùå No
                const ambassadorMatch = line.match(/Ambassador\s+Led:\*\*\s*[‚úÖ‚ùå]?\s*(Yes|No)/i);
                if (ambassadorMatch && currentGroup) {
                    currentGroup.ambassador = ambassadorMatch[1].charAt(0).toUpperCase() + ambassadorMatch[1].slice(1).toLowerCase();
                }
            }
            
            // Don't forget the last group
            if (currentGroup) {
                groups.push(currentGroup);
            }

            console.log('Parsed groups:', groups.length, groups);

            // Sort: Ambassador Led Yes first, then No, then Unknown
            const sortedGroups = groups.slice().sort((a, b) => {
                const val = v => {
                    if (!v || typeof v !== 'string') return 2; // Unknown
                    const s = v.toLowerCase();
                    if (s === 'yes') return 0;
                    if (s === 'no') return 1;
                    return 2;
                };
                return val(a.ambassador) - val(b.ambassador);
            });

            // If nothing parsed, show a helpful message
            if (!sortedGroups.length) {
                console.error('No groups parsed from campfire.md');
                container.innerHTML = '<div class="error">No Campfire groups could be parsed. Please verify campfire.md uses the format: <strong>### Group Name</strong> on one line, a [Join Group](url) link, and \'- **Ambassador Led:** ‚úÖ Yes/‚ùå No\' line.</div>';
                return;
            }

            console.log('Rendering', sortedGroups.length, 'sorted groups');

            // Render groups as cards similar to events
            container.innerHTML = `
                <div class="event-grid">
                    ${sortedGroups.map(group => {
                        const joinButton = group.link ? 
                            `<a href="${group.link}" target="_blank" rel="noopener noreferrer" class="join-btn">üî• Join Group</a>` : 
                            '<span class="join-btn disabled">Link Not Available</span>';
                        const ambassadorLine = typeof group.ambassador === 'string' && group.ambassador
                            ? (() => {
                                const val = (group.ambassador || '').toLowerCase();
                                const cls = val === 'yes' ? 'ambassador-yes' : (val === 'no' ? 'ambassador-no' : 'ambassador-unknown');
                                return `<div class=\"campfire-meta\"><span class=\"meta-item ambassador-badge ${cls}\">üë• Ambassador Led: ${group.ambassador}</span></div>`;
                              })()
                            : '';
                        return `
                            <div class="event-card campfire-card">
                                <h3>${group.name}</h3>
                                ${ambassadorLine}
                                <div class="campfire-actions">
                                    ${joinButton}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function showTab(tabName, tabLabel) {
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.style.display = 'none');
            
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(`${tabName}-tab`).style.display = 'block';
            
            // Find and activate the clicked button
            const clickedButton = Array.from(buttons).find(btn => 
                btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(tabName)
            );
            if (clickedButton) {
                clickedButton.classList.add('active');
            }

            // Update mobile nav toggle text
            const mobileToggle = document.querySelector('.mobile-nav-toggle .current-tab');
            if (mobileToggle && tabLabel) {
                mobileToggle.textContent = tabLabel;
            }

            // Close mobile nav after selection
            closeMobileNav();
        }

        function toggleMobileNav() {
            const navTabs = document.getElementById('nav-tabs');
            navTabs.classList.toggle('mobile-open');
        }

        function closeMobileNav() {
            const navTabs = document.getElementById('nav-tabs');
            navTabs.classList.remove('mobile-open');
        }

        // Close mobile nav when clicking outside
        document.addEventListener('click', function(event) {
            const navContainer = document.querySelector('.nav-container');
            const navTabs = document.getElementById('nav-tabs');
            
            if (!navContainer.contains(event.target) && navTabs.classList.contains('mobile-open')) {
                closeMobileNav();
            }
        });

        // Initialize - Load all markdown files
        async function init() {
            // Load events
            const eventsMarkdown = await loadMarkdownFile('events.md');
            if (eventsMarkdown) {
                eventsData = parseEvents(eventsMarkdown);
                renderEvents();
            } else {
                console.error('Failed to load events.md');
            }

            // Load signature event
            const signatureMarkdown = await loadMarkdownFile('signature.md');
            signatureData = parseSignatureEvent(signatureMarkdown || '');
            if (signatureData) {
                renderSignature();
            }

            // Load campfire groups
            const campfireMarkdown = await loadMarkdownFile('campfire.md');
            if (campfireMarkdown) {
                campfireData = campfireMarkdown;
                renderCampfire();
            }
        }

        // Load content when page loads
        // Initialize sticky mobile nav behavior
        function setupStickyMobileNav() {
            const navContainer = document.querySelector('.nav-container');
            if (!navContainer) return;

            let navTop = navContainer.getBoundingClientRect().top + window.scrollY;

            function updateNav() {
                // Only use sticky behavior on narrow viewports
                if (window.innerWidth > 768) {
                    navContainer.classList.remove('fixed');
                    document.body.classList.remove('nav-fixed');
                    document.body.style.removeProperty('--nav-height');
                    return;
                }

                const navHeight = navContainer.getBoundingClientRect().height;
                // Save nav height to a CSS variable so we can pad content
                document.body.style.setProperty('--nav-height', `${navHeight}px`);

                if (window.scrollY > navTop) {
                    if (!navContainer.classList.contains('fixed')) {
                        navContainer.classList.add('fixed');
                        document.body.classList.add('nav-fixed');
                    }
                } else {
                    if (navContainer.classList.contains('fixed')) {
                        navContainer.classList.remove('fixed');
                        document.body.classList.remove('nav-fixed');
                    }
                }
            }

            // Recalculate anchor position on resize/paint
            function recompute() {
                navTop = navContainer.getBoundingClientRect().top + window.scrollY;
                updateNav();
            }

            window.addEventListener('scroll', updateNav, { passive: true });
            window.addEventListener('resize', recompute);
            // run once to set initial state
            recompute();
        }

        init();
        setupStickyMobileNav();
        
        // Add to Home Screen functionality
        let deferredPrompt;
        const installBanner = document.getElementById('install-banner');
        const installButton = document.getElementById('install-button');
        const dismissButton = document.getElementById('install-dismiss');

        // Check if already installed or dismissed
        const isInstalled = localStorage.getItem('pwa-installed') === 'true';
        const isDismissed = localStorage.getItem('install-banner-dismissed') === 'true';

        // Listen for the beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the default browser install prompt
            e.preventDefault();
            deferredPrompt = e;
            
            // Show our custom banner if not dismissed and not installed
            if (!isInstalled && !isDismissed) {
                setTimeout(() => {
                    installBanner.style.display = 'block';
                }, 3000); // Show after 3 seconds
            }
        });

        // Install button click handler
        if (installButton) {
            installButton.addEventListener('click', async () => {
                if (!deferredPrompt) {
                    return;
                }
                
                // Show the install prompt
                deferredPrompt.prompt();
                
                // Wait for the user's response
                const { outcome } = await deferredPrompt.userChoice;
                
                if (outcome === 'accepted') {
                    localStorage.setItem('pwa-installed', 'true');
                }
                
                // Clear the deferred prompt
                deferredPrompt = null;
                
                // Hide the banner
                installBanner.style.display = 'none';
            });
        }

        // Dismiss button click handler
        if (dismissButton) {
            dismissButton.addEventListener('click', () => {
                installBanner.style.display = 'none';
                localStorage.setItem('install-banner-dismissed', 'true');
                
                // Auto-show again after 7 days
                setTimeout(() => {
                    localStorage.removeItem('install-banner-dismissed');
                }, 7 * 24 * 60 * 60 * 1000);
            });
        }

        // Detect if app was launched from home screen
        window.addEventListener('appinstalled', () => {
            localStorage.setItem('pwa-installed', 'true');
            installBanner.style.display = 'none';
        });

        // For iOS Safari - show a different message since they don't support beforeinstallprompt
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isStandalone = window.navigator.standalone === true;
        
        if (isIOS && !isStandalone && !isDismissed) {
            setTimeout(() => {
                const iosBanner = document.getElementById('install-banner');
                const iosText = iosBanner.querySelector('.install-banner-text');
                iosText.innerHTML = `
                    <strong>üì± Install DFW PoGO</strong>
                    <p>Tap <span style="font-size: 1.2em;">‚éã</span> then "Add to Home Screen"</p>
                `;
                installButton.style.display = 'none'; // Hide install button on iOS
                iosBanner.style.display = 'block';
            }, 3000);
        }
    </script>
    <footer class="site-footer">
        <div class="container">
            <a class="discord-btn sticky" href="https://discord.gg/Yc6rg2a5xe" target="_blank" rel="noopener noreferrer" aria-label="Join our Discord server">Join our Discord Server</a>
        </div>
    </footer>
    <script>
        // Register service worker if supported
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('Service worker registered with scope:', reg.scope))
                .catch(err => console.warn('Service worker registration failed:', err));
        }
    </script>
</body>
</html>
