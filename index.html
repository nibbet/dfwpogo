<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFW Pokemon GO</title>
    <!-- PWA: manifest and theme color -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6E46A6">
    <link rel="apple-touch-icon" href="img/apple-touch-icon.png">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="DFW PoGO">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <link rel="stylesheet" href="css/styles.css">
    <link
        rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-o9N1j7kCwWZ8zJkB8gE2S0ZL0Ydqg9O6bHsWv4fZlOs="
        crossorigin=""
    >
    <script
        src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-o5dR7A1mQiaxU9n32CuWHa3gwZMObn2yZk3xP2Vt7uM="
        crossorigin=""
        defer
    ></script>
    <script>
        // Use marked defaults and enable GFM + line breaks
        marked.setOptions({
            gfm: true,
            breaks: true
        });

        // No collapsible behavior ‚Äî headers will be static purple sections
    </script>
</head>
<body>
    <div class="header">
        <h1>DFW Pok√©mon Go</h1>
        <p>Your guide to local community events and Campfire groups</p>
        <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle dark mode">
            <span class="toggle-icon">üåô</span>
        </button>
    </div>

    <div class="container">
        <div class="nav-container">
            <button class="mobile-nav-toggle" onclick="toggleMobileNav()">
                <span class="current-tab"></span>
                <span class="hamburger">‚ò∞</span>
            </button>
            <div class="nav-tabs" id="nav-tabs">
                <button id="signature-tab-btn" class="tab-btn" onclick="showTab('signature', 'üåü Signature Events')">üåü Signature Events</button>
                <button id="leadup-tab-btn" class="tab-btn" onclick="showTab('leadup', '‚è≥ Lead-Up Week')">‚è≥ Lead-Up Week</button>
                <button id="meetup-tab-btn" class="tab-btn" onclick="showTab('meetup', 'üìç Meetup Locations')">üìç Meetup Locations</button>
                <button class="tab-btn" onclick="showTab('campfire', 'üî• Campfire Groups')">üî• Campfire Groups</button>
                <button class="tab-btn" onclick="showTab('events', 'üìÖ Pok√©mon Go Events')">üìÖ Pok√©mon Go Events</button>
                <button id="locations-tab-btn" class="tab-btn" onclick="showTab('locations', 'üó∫Ô∏è Locations Map')">üó∫Ô∏è Locations Map</button>
                <button id="wallpapers-tab-btn" class="tab-btn" onclick="showTab('wallpapers', 'üñº Wallpapers')">üñº Wallpapers</button>
            </div>
        </div>

        <div class="content-area">
            <div id="events-tab" class="tab-content" style="display:none;">
                <h2>Upcoming Events</h2>
                <div id="events-list" class="event-grid">
                    <div class="loading">Loading events...</div>
                </div>
            </div>

            <div id="locations-tab" class="tab-content" style="display:none;">
                <h2>Locations Map</h2>
                <div class="locations-map-wrapper">
                    <div id="locations-map" class="locations-map">Loading map...</div>
                </div>
                <div id="locations-list" class="locations-list markdown-content">
                    <div class="loading">Loading locations...</div>
                </div>
            </div>

            <div id="leadup-tab" class="tab-content" style="display:none;">
                <div id="leadup-content" class="markdown-content">
                    <div class="loading">Loading lead-up week...</div>
                </div>
            </div>

            <div id="signature-tab" class="tab-content" style="display:none;">
                <div id="signature-content" class="markdown-content">
                    <div class="loading">Loading signature event...</div>
                </div>
            </div>
            <div id="meetup-tab" class="tab-content" style="display:none;">
                <div id="meetup-content" class="markdown-content">
                    <div class="loading">Loading meetup info...</div>
                </div>
            </div>

            <div id="campfire-tab" class="tab-content" style="display:none;">
                <div id="campfire-list" class="event-grid">
                    <div class="loading">Loading Campfire groups...</div>
                </div>
            </div>

            <div id="wallpapers-tab" class="tab-content" style="display:none;">
                <div id="wallpapers-content" class="markdown-content">
                    <div class="loading">Loading wallpapers...</div>
                </div>
            </div>
        </div>

    </div>

    <!-- Add to Home Screen Banner -->
    <div id="install-banner" class="install-banner" style="display: none;">
        <div class="install-banner-content">
            <div class="install-banner-text">
                <strong>üì± Install DFW PoGO</strong>
                <p>Add to your home screen for quick access!</p>
            </div>
            <div class="install-banner-actions">
                <button id="install-button" class="install-btn">Install</button>
                <button id="install-dismiss" class="install-dismiss">‚úï</button>
            </div>
        </div>
    </div>

    <!-- Pull to Refresh Indicator (mobile only) -->
    <div id="pull-to-refresh" class="pull-to-refresh" aria-hidden="true">
        <div class="ptr-inner">
            <span class="ptr-icon">‚Üì</span>
            <span class="ptr-text">Pull to refresh</span>
        </div>
    </div>

    <script>
        // ==========================================
        // MAINTENANCE MODE - Change to true to enable
        // ==========================================
        const MAINTENANCE_MODE = false;
        
        let eventsData = [];
        let campfireData = '';
        let signatureData = '';
        let meetupData = '';
        let signatureTitle = localStorage.getItem('lastSignatureTitle') || 'Signature Events';
        let meetupTitle = localStorage.getItem('lastMeetupTitle') || 'Meetup Locations';
        let locationsData = [];
        let locationsMap = null;
        let locationsLayer = null;

        // Constants for localStorage
        const STORAGE_KEYS = {
            TITLE: 'lastSignatureTitle',
            LAST_UPDATED: 'signatureTitleLastUpdated',
            MEETUP_TITLE: 'lastMeetupTitle',
            MEETUP_LAST_UPDATED: 'meetupTitleLastUpdated'
        };

        // Cache duration (24 hours in milliseconds)
        const CACHE_DURATION = 24 * 60 * 60 * 1000;
        // Data refresh cadence: re-fetch content when returning to tab after this interval
        const DATA_REFRESH_INTERVAL = 7 * 24 * 60 * 60 * 1000; // 7 days
        let lastDataRefresh = 0;

        // Load markdown files from GitHub with light cache-busting
        async function loadMarkdownFile(filename) {
            try {
                const cacheBuster = Math.floor(Date.now() / DATA_REFRESH_INTERVAL);
                const url = filename.includes('?') ? `${filename}&v=${cacheBuster}` : `${filename}?v=${cacheBuster}`;
                const response = await fetch(url, { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}`);
                }
                return await response.text();
            } catch (error) {
                console.error(`Error loading ${filename}:`, error);
                return null;
            }
        }

        // Load and render all content blocks
        async function loadContent() {
            // Load and render lead-up week
            const leadupMarkdown = await loadMarkdownFile('signature_leadup.md');
            // renderLeadup handles empty/missing content and hides tab if needed
            renderLeadup(leadupMarkdown || '');

            // Load events
            const eventsMarkdown = await loadMarkdownFile('events.md');
            if (eventsMarkdown) {
                eventsData = parseEvents(eventsMarkdown);
                renderEvents();
            } else {
                console.error('Failed to load events.md');
            }

            // Load signature event
            const signatureMarkdown = await loadMarkdownFile('signature.md');
            signatureData = parseSignatureEvent(signatureMarkdown || '');
            if (signatureData) {
                renderSignature();
                // Update mobile nav toggle after signature title is loaded
                const mobileToggle = document.querySelector('.mobile-nav-toggle .current-tab');
                const tabBtn = document.getElementById('signature-tab-btn');
                if (mobileToggle && tabBtn && tabBtn.classList.contains('active')) {
                    const displayTitle = signatureTitle.length > 25 
                        ? signatureTitle.substring(0, 22) + '...' 
                        : signatureTitle;
                    mobileToggle.textContent = `üåü ${displayTitle}`;
                }
            }

            // Load meetup markdown
            const meetupMarkdown = await loadMarkdownFile('signature_meetup.md');
            meetupData = parseMeetupEvent(meetupMarkdown || '');
            if (meetupData) {
                renderMeetup();
            }

            // Load campfire groups
            campfireData = await loadMarkdownFile('campfire.md');
            if (campfireData) {
                renderCampfire();
            } else {
                console.error('Failed to load campfire.md');
            }

            // Load locations map data
            const locationsMarkdown = await loadMarkdownFile('locations.md');
            locationsData = parseLocations(locationsMarkdown || '');
            renderLocations();

            // Load wallpapers (optional)
            const wallpapersMarkdown = await loadMarkdownFile('wallpapers.md');
            if (wallpapersMarkdown) {
                renderWallpapers(wallpapersMarkdown);
                const btn = document.getElementById('wallpapers-tab-btn');
                if (btn) btn.style.display = '';
            } else {
                // Hide the Wallpapers tab if not available
                const btn = document.getElementById('wallpapers-tab-btn');
                if (btn) btn.style.display = 'none';
                const tab = document.getElementById('wallpapers-tab');
                if (tab) tab.style.display = 'none';
            }

            lastDataRefresh = Date.now();
        }

        // Parse events and filter out past events
        function parseEvents(markdown) {
            if (!markdown) return [];
            const events = [];
            const sections = markdown.split('##').filter(s => s.trim());
            const today = new Date();
            sections.forEach(section => {
                const lines = section.trim().split('\n');
                const title = lines[0].trim();
                const content = lines.slice(1).join('\n');
                const dateMatch = content.match(/\*\*Date:\*\*\s*(.+)/);
                const pokemonMatch = content.match(/\*\*Featured Pokemon:\*\*\s*(.+)/);
                const typeMatch = content.match(/\*\*Type:\*\*\s*(.+)/);
                const timeMatch = content.match(/\*\*Time\*\*\s*:?\s*(.+)/);
                let cleanContent = content
                    .replace(/\*\*Date:\*\*[^\n]*\n?/g, '')
                    .replace(/\*\*Featured Pokemon:\*\*[^\n]*\n?/g, '')
                    .replace(/\*\*Type:\*\*[^\n]*\n?/g, '')
                    .replace(/\*\*Time\*\*\s*:?.*\n?/g, '')
                    .trim();
                // Parse the date for filtering
                let eventDate = null;
                if (dateMatch) {
                    let dateStr = dateMatch[1].split(/[‚Äì-]/)[0].trim();
                    if (!/\d{4}/.test(dateStr) && /\d{4}/.test(dateMatch[1])) {
                        dateStr += ', ' + dateMatch[1].match(/\d{4}/)[0];
                    }
                    eventDate = new Date(dateStr);
                }
                let isUpcoming = true;
                if (eventDate instanceof Date && !isNaN(eventDate)) {
                    const eventDay = new Date(eventDate.getFullYear(), eventDate.getMonth(), eventDate.getDate());
                    const todayDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                    isUpcoming = eventDay >= todayDay;
                }
                if (isUpcoming) {
                    events.push({
                        title,
                        date: dateMatch ? dateMatch[1].trim() : 'TBA',
                        time: timeMatch ? timeMatch[1].trim() : '',
                        pokemon: pokemonMatch ? pokemonMatch[1].trim() : '',
                        type: typeMatch ? typeMatch[1].trim().toLowerCase().replace(/\s+/g, '-') : 'event',
                        content: marked.parse(cleanContent)
                    });
                }
            });
            return events;
        }

        // Parse locations markdown into objects with lat/lng
        function parseLocations(markdown) {
            if (!markdown) return [];
            const sections = markdown.split(/^###\s+/m).filter(Boolean);
            const results = [];
            sections.forEach(block => {
                const lines = block.trim().split('\n');
                if (!lines.length) return;
                const name = lines[0].trim();
                const body = lines.slice(1).join('\n');
                // Try multiple formats
                const latMatch = body.match(/lat\s*[:=]\s*([\d.-]+)/i);
                const lngMatch = body.match(/(lng|lon|long|longitude)\s*[:=]\s*([\d.-]+)/i);
                const coordMatch = body.match(/coords?\s*[:=]\s*([\d.-]+)\s*,\s*([\d.-]+)/i);
                let lat = null, lng = null;
                if (coordMatch) {
                    lat = parseFloat(coordMatch[1]);
                    lng = parseFloat(coordMatch[2]);
                } else {
                    if (latMatch) lat = parseFloat(latMatch[1]);
                    if (lngMatch) lng = parseFloat(lngMatch[2]);
                }
                const addressMatch = body.match(/address\s*[:=]\s*(.+)/i);
                const notesMatch = body.match(/notes?\s*[:=]\s*(.+)/i);
                const desc = body.replace(/^(?:[-*]\s*)?(lat|lng|lon|long|longitude|coords?|address|notes?)\s*[:=].*$/gmi, '').trim();
                results.push({
                    name,
                    lat: isFinite(lat) ? lat : null,
                    lng: isFinite(lng) ? lng : null,
                    address: addressMatch ? addressMatch[1].trim() : '',
                    notes: notesMatch ? notesMatch[1].trim() : desc
                });
            });
            return results;
        }

        function parseSignatureEvent(markdown) {
            if (!markdown || !markdown.trim()) {
                hideSignatureTab();
                return '';
            }
            
            // Extract title from first h1
            const titleMatch = markdown.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                const newTitle = titleMatch[1].trim();
                updateSignatureTitle(newTitle);
                showSignatureTab();
            } else {
                // Try to use cached title if available and not expired
                const cachedTitle = getCachedTitle();
                if (cachedTitle) {
                    signatureTitle = cachedTitle;
                    updateSignatureTabLabel();
                    showSignatureTab();
                } else {
                    hideSignatureTab();
                }
            }
            return marked.parse(markdown);
        }

        function parseMeetupEvent(markdown) {
            if (!markdown || !markdown.trim()) {
                hideMeetupTab();
                return '';
            }
            const titleMatch = markdown.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                const newTitle = titleMatch[1].trim();
                updateMeetupTitle(newTitle);
                showMeetupTab();
            } else {
                const cached = getCachedMeetupTitle();
                if (cached) {
                    meetupTitle = cached;
                    updateMeetupTabLabel();
                    showMeetupTab();
                } else {
                    hideMeetupTab();
                }
            }
            return marked.parse(markdown);
        }

        function updateMeetupTitle(newTitle) {
            meetupTitle = newTitle;
            localStorage.setItem(STORAGE_KEYS.MEETUP_TITLE, newTitle);
            localStorage.setItem(STORAGE_KEYS.MEETUP_LAST_UPDATED, Date.now().toString());
            updateMeetupTabLabel();
        }

        function getCachedMeetupTitle() {
            const lastUpdated = parseInt(localStorage.getItem(STORAGE_KEYS.MEETUP_LAST_UPDATED) || '0');
            const cached = localStorage.getItem(STORAGE_KEYS.MEETUP_TITLE);
            if (cached && Date.now() - lastUpdated < CACHE_DURATION) return cached;
            localStorage.removeItem(STORAGE_KEYS.MEETUP_TITLE);
            localStorage.removeItem(STORAGE_KEYS.MEETUP_LAST_UPDATED);
            return null;
        }

        function updateMeetupTabLabel() {
            const tabBtn = document.getElementById('meetup-tab-btn');
            if (!tabBtn) return;
            const displayTitle = meetupTitle.length > 22 ? meetupTitle.substring(0,19) + '‚Ä¶' : meetupTitle;
            tabBtn.innerHTML = `üìç ${displayTitle}`;
            tabBtn.setAttribute('onclick', `showTab('meetup', 'üìç ${displayTitle}')`);
            const mobileToggle = document.querySelector('.mobile-nav-toggle .current-tab');
            if (mobileToggle && tabBtn.classList.contains('active')) mobileToggle.textContent = `üìç ${displayTitle}`;
        }

        function hideMeetupTab() {
            const tabBtn = document.getElementById('meetup-tab-btn');
            if (tabBtn) {
                tabBtn.style.display = 'none';
                if (tabBtn.classList.contains('active')) showTab('signature','üåü Signature Events');
            }
            const tab = document.getElementById('meetup-tab');
            if (tab) tab.style.display = 'none';
        }

        function showMeetupTab() {
            const tabBtn = document.getElementById('meetup-tab-btn');
            if (tabBtn) tabBtn.style.display = '';
        }

        function hideLeadupTab() {
            const tabBtn = document.getElementById('leadup-tab-btn');
            if (tabBtn) {
                tabBtn.style.display = 'none';
                if (tabBtn.classList.contains('active')) showTab('signature','üåü Signature Events');
            }
            const tab = document.getElementById('leadup-tab');
            if (tab) tab.style.display = 'none';
        }

        function showLeadupTab() {
            const tabBtn = document.getElementById('leadup-tab-btn');
            if (tabBtn) tabBtn.style.display = '';
        }

        function updateSignatureTitle(newTitle) {
            signatureTitle = newTitle;
            // Cache the new title
            localStorage.setItem(STORAGE_KEYS.TITLE, newTitle);
            localStorage.setItem(STORAGE_KEYS.LAST_UPDATED, Date.now().toString());
            updateSignatureTabLabel();
        }

        function getCachedTitle() {
            const lastUpdated = parseInt(localStorage.getItem(STORAGE_KEYS.LAST_UPDATED) || '0');
            const cachedTitle = localStorage.getItem(STORAGE_KEYS.TITLE);
            
            // Check if cache exists and isn't expired
            if (cachedTitle && Date.now() - lastUpdated < CACHE_DURATION) {
                return cachedTitle;
            }
            
            // Clear expired cache
            localStorage.removeItem(STORAGE_KEYS.TITLE);
            localStorage.removeItem(STORAGE_KEYS.LAST_UPDATED);
            return null;
        }

        function updateSignatureTabLabel() {
            const tabBtn = document.getElementById('signature-tab-btn');
            if (!tabBtn) return;
            
            // Shorten title if it's too long
            const displayTitle = signatureTitle.length > 25 
                ? signatureTitle.substring(0, 22) + '...' 
                : signatureTitle;
            tabBtn.innerHTML = `üåü ${displayTitle}`;
            tabBtn.setAttribute('onclick', `showTab('signature', 'üåü ${displayTitle}')`);
            
            // Update mobile nav toggle text if signature tab is active
            const mobileToggle = document.querySelector('.mobile-nav-toggle .current-tab');
            const isActive = tabBtn.classList.contains('active');
            if (mobileToggle && isActive) {
                mobileToggle.textContent = `üåü ${displayTitle}`;
            }
        }

        // Wrap tables to enable horizontal scrolling on mobile and add a visible hint
        function applyTableEnhancements(root) {
            if (!root) return;
            const tables = root.querySelectorAll('.markdown-content table, .signature-overview table');
            tables.forEach(table => {
                if (table.parentElement && table.parentElement.classList.contains('table-scroll')) return;
                const wrapper = document.createElement('div');
                wrapper.className = 'table-scroll';
                table.parentNode.insertBefore(wrapper, table);
                wrapper.appendChild(table);
                const hint = document.createElement('div');
                hint.className = 'scroll-hint';
                hint.textContent = 'Scroll ‚Üí';
                wrapper.appendChild(hint);
            });
        }

        function hideSignatureTab() {
            const tabBtn = document.getElementById('signature-tab-btn');
            if (tabBtn) {
                tabBtn.classList.add('hiding');
                // Wait for transition before hiding
                setTimeout(() => {
                    // If we previously moved the tab, attempt to restore its original position
                    const navTabs = document.getElementById('nav-tabs');
                    if (tabBtn.dataset && tabBtn.dataset.originalIndex) {
                        const originalIndex = parseInt(tabBtn.dataset.originalIndex, 10);
                        // If originalIndex is within bounds, insert before that child, otherwise append
                        if (!isNaN(originalIndex) && originalIndex < navTabs.children.length) {
                            navTabs.insertBefore(tabBtn, navTabs.children[originalIndex]);
                        } else {
                            navTabs.appendChild(tabBtn);
                        }
                        delete tabBtn.dataset.originalIndex;
                    }

                    tabBtn.style.display = 'none';
                    tabBtn.classList.remove('hiding');
                    // If signature tab was active, switch to events tab
                    if (tabBtn.classList.contains('active')) {
                        showTab('events', 'üìÖ Events');
                    }
                }, 300); // Match transition duration
            }
            const signatureTab = document.getElementById('signature-tab');
            if (signatureTab) {
                signatureTab.style.display = 'none';
            }
        }

        function showSignatureTab() {
            const tabBtn = document.getElementById('signature-tab-btn');
            if (tabBtn) {
                // Move the signature tab to the front when visible, remembering original position
                const navTabs = document.getElementById('nav-tabs');
                if (navTabs && !tabBtn.dataset.originalIndex) {
                    const children = Array.from(navTabs.children);
                    const idx = children.indexOf(tabBtn);
                    if (idx !== -1) tabBtn.dataset.originalIndex = idx;
                    navTabs.insertBefore(tabBtn, navTabs.firstChild);
                }

                // Reset visibility without transition
                tabBtn.classList.remove('hiding');
                tabBtn.style.opacity = '0';
                tabBtn.style.display = '';

                // Trigger transition
                requestAnimationFrame(() => {
                    tabBtn.style.opacity = '1';
                });
            }
        }

        function renderEvents() {
            const container = document.getElementById('events-list');
            
            if (eventsData.length === 0) {
                container.innerHTML = '<div class="error">No events found. Please ensure events.md exists in your repository.</div>';
                return;
            }
            // Inject a header/description card once per load
            const tabRoot = document.getElementById('events-tab');
            if (tabRoot && !document.getElementById('events-header-card')) {
                const headerCard = document.createElement('div');
                headerCard.className = 'signature-card signature-header-card';
                headerCard.id = 'events-header-card';
                const titleEl = document.createElement('h1');
                titleEl.textContent = 'Pok√©mon GO Events';
                headerCard.appendChild(titleEl);
                const overview = document.createElement('div');
                overview.className = 'signature-overview';
                overview.innerHTML = '<p>Browse upcoming local and global Pok√©mon GO happenings: raid hours, spotlight hours, Max Battles, weekends and special events. Only future events are shown.</p>';
                headerCard.appendChild(overview);
                tabRoot.insertBefore(headerCard, tabRoot.firstChild);
            }
            
            container.innerHTML = eventsData.map(event => {
                // event.content comes pre-parsed (HTML) and metadata lines were removed in parseEvents
                const processedContent = event.content;
                const timeDisplay = event.time ? `<p><strong>üïí ${event.time}</strong></p>` : '';

                return `
                <div class="event-card">
                    <span class="event-type type-${event.type}">${event.type.replace(/-/g, ' ').toUpperCase()}</span>
                    <h3>${event.title}</h3>
                    <p><strong>üìÖ ${event.date}</strong></p>
                    ${timeDisplay}
                    ${event.pokemon ? `<p><strong>‚ö° Featured: ${event.pokemon}</strong></p>` : ''}
                    <div class="markdown-content">${processedContent}</div>
                </div>
                `;
            }).join('');
        }

        function renderSignature() {
            const container = document.getElementById('signature-content');

            if (!signatureData) {
                container.innerHTML = '<div class="error">No signature event found. Please ensure signature.md exists in your repository.</div>';
                return;
            }

            // Parse the pre-rendered HTML from marked
            const temp = document.createElement('div');
            temp.innerHTML = signatureData;

            // Extract title from H1
            const h1 = temp.querySelector('h1');
            const titleText = h1 ? h1.textContent.trim() : 'Signature Event';
            if (h1) h1.remove();

            // Extract the first H2 section for metadata
            const firstH2 = temp.querySelector('h2');
            let metaContent = null;
            if (firstH2 && firstH2.textContent.includes('Overview')) {
                // Get all content between first H2 and second H2
                metaContent = document.createElement('div');
                let node = firstH2.nextSibling;
                const secondH2 = Array.from(temp.querySelectorAll('h2'))[1];
                while (node && node !== secondH2) {
                    const next = node.nextSibling;
                    if (node.nodeType === 1 || (node.nodeType === 3 && node.textContent.trim())) {
                        metaContent.appendChild(node.cloneNode(true));
                    }
                    node = next;
                }
                firstH2.remove();
            }

            // Build the card
            container.innerHTML = '';
            
            // Create header card with title and overview
            const headerCard = document.createElement('div');
            headerCard.className = 'signature-card signature-header-card';
            
            const title = document.createElement('h1');
            title.textContent = titleText;
            headerCard.appendChild(title);
            
            if (metaContent && metaContent.innerHTML.trim()) {
                const overview = document.createElement('div');
                overview.className = 'signature-overview';
                overview.innerHTML = metaContent.innerHTML;
                headerCard.appendChild(overview);
            }

            // Add quick link to Meetup Locations tab inside the header card
            const meetupDisplayTitle = (meetupTitle && meetupTitle.length > 22) ? (meetupTitle.substring(0,19) + '‚Ä¶') : (meetupTitle || 'Meetup Locations');
            const meetupCta = document.createElement('a');
            meetupCta.href = '#meetup';
            meetupCta.className = 'meta-item meta-link meta-inverse';
            meetupCta.textContent = `üìç ${meetupDisplayTitle}`;
            meetupCta.addEventListener('click', (e) => {
                e.preventDefault();
                showTab('meetup', `üìç ${meetupDisplayTitle}`);
            });
            headerCard.appendChild(meetupCta);
            
            // Add quick link to Lead-Up Week tab next to Meetup
            const leadupTabBtn = document.getElementById('leadup-tab-btn');
            const leadupLabel = leadupTabBtn ? leadupTabBtn.textContent.trim() : '‚è≥ Lead-Up Week';
            const leadupCta = document.createElement('a');
            leadupCta.href = '#leadup';
            leadupCta.className = 'meta-item meta-link meta-inverse';
            leadupCta.textContent = leadupLabel;
            leadupCta.addEventListener('click', (e) => {
                e.preventDefault();
                showTab('leadup', leadupLabel);
            });
            headerCard.appendChild(leadupCta);
            
            container.appendChild(headerCard);

            // Process remaining H2 sections as individual cards
            const allH2s = Array.from(temp.querySelectorAll('h2'));
            
            allH2s.forEach((h2) => {
                const sectionCard = document.createElement('div');
                sectionCard.className = 'event-card signature-section-card';
                
                // Add section title
                const sectionTitle = document.createElement('h2');
                sectionTitle.innerHTML = h2.innerHTML;
                sectionCard.appendChild(sectionTitle);
                
                // Collect content until next H2
                const content = document.createElement('div');
                content.className = 'markdown-content';
                
                let node = h2.nextSibling;
                const nextH2 = allH2s[allH2s.indexOf(h2) + 1];
                while (node && node !== nextH2) {
                    const next = node.nextSibling;
                    if (node.nodeType === 1 || (node.nodeType === 3 && node.textContent.trim())) {
                        content.appendChild(node.cloneNode(true));
                    }
                    node = next;
                }
                
                sectionCard.appendChild(content);
                container.appendChild(sectionCard);
            });

            // Enhance any tables for better mobile behavior
            applyTableEnhancements(container);
        }

        function renderMeetup() {
            const container = document.getElementById('meetup-content');
            if (!meetupData) {
                container.innerHTML = '<div class="error">No meetup info found. Ensure signature_meetup.md exists.</div>';
                return;
            }
            const temp = document.createElement('div');
            temp.innerHTML = meetupData;
            const h1 = temp.querySelector('h1');
            if (h1) h1.remove();
            const sections = Array.from(temp.querySelectorAll('h2'));
            
            // Sort Saturday and Sunday location lists alphabetically by location name
            const sortLocationList = (rootHeading) => {
                if (!rootHeading) return;
                let nodes = [];
                let n = rootHeading.nextSibling;
                while (n && !(n.nodeType === 1 && n.tagName === 'H2')) {
                    nodes.push(n);
                    n = n.nextSibling;
                }
                // Extract list items (lines starting with -, * and containing a dash time marker)
                const locationBlocks = [];
                let buffer = [];
                nodes.forEach(node => {
                    if (node.nodeType === 3 && !node.textContent.trim()) return; // skip pure whitespace text nodes
                    buffer.push(node);
                    if (node.nodeType === 1 && node.tagName === 'BR') return; // ignore breaks
                    // Heuristic: a line with time markers or ends with 'PM'/'AM' stored separately
                });
                // Simpler approach: rebuild innerHTML, split lines, sort, re-inject
                const contentHTML = nodes.map(nd => nd.outerHTML || nd.textContent).join('\n');
                const lines = contentHTML.split(/\n/).map(l => l.trim()).filter(l => l.length);
                // Only sort if this looks like a meetup list (contains 'AM' or 'PM')
                if (lines.some(l => /(AM|PM)/.test(l))) {
                    // Group pairs: location line + optional time line following starting with '-' or '*'
                    const grouped = [];
                    for (let i=0; i<lines.length; i++) {
                        const line = lines[i];
                        if (/^(?:-|\*)\s*\[?.+?(AM|PM)/i.test(line) || /\bAM\b|\bPM\b/.test(line)) {
                            grouped.push({name: line, extra: ''});
                        } else {
                            // Try to attach lines that are not headings but follow
                            if (grouped.length) {
                                grouped[grouped.length-1].extra += (grouped[grouped.length-1].extra? '\n':'') + line;
                            }
                        }
                    }
                    grouped.sort((a,b) => a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
                    const rebuilt = grouped.map(g => g.extra ? `${g.name}\n${g.extra}` : g.name).join('\n');
                    // Replace original block
                    // Remove original nodes
                    nodes.forEach(nd => nd.remove());
                    // Inject sorted lines as paragraphs for simplicity
                    rebuilt.split(/\n/).forEach(line => {
                        const p = document.createElement('p');
                        p.innerHTML = line;
                        rootHeading.parentNode.insertBefore(p, n); // insert before next section heading or end
                    });
                }
            };
            // Apply sorting to headings containing 'Saturday' or 'Sunday'
            sections.forEach(h => {
                if (/Saturday/i.test(h.textContent) || /Sunday/i.test(h.textContent)) {
                    sortLocationList(h);
                }
            });
            container.innerHTML = '';
            // Simple header card
            const headCard = document.createElement('div');
            headCard.className = 'signature-card signature-header-card';
            const titleEl = document.createElement('h1');
            titleEl.textContent = meetupTitle || 'Meetup Locations';
            headCard.appendChild(titleEl);
            // Last updated badge
            const updatedSpan = document.createElement('span');
            updatedSpan.className = 'meta-item meta-inverse last-updated-badge';
            const now = new Date();
            updatedSpan.textContent = `üïí Last Updated: ${now.toLocaleDateString(undefined,{month:'short', day:'numeric', year:'numeric'})}`;
            headCard.appendChild(updatedSpan);
            // Overview description for meetup tab
            const overviewBlock = document.createElement('div');
            overviewBlock.className = 'signature-overview';
            overviewBlock.innerHTML = '<p>Find suggested community meetup locations for event days. Times indicate when local trainers are most active‚Äîcoordinate, raid and explore together.</p>';
            headCard.appendChild(overviewBlock);
            container.appendChild(headCard);
            sections.forEach(h2 => {
                const card = document.createElement('div');
                card.className = 'event-card signature-section-card';
                const secTitle = document.createElement('h2');
                secTitle.innerHTML = h2.innerHTML;
                card.appendChild(secTitle);
                const content = document.createElement('div');
                content.className = 'markdown-content';
                let node = h2.nextSibling;
                while (node && !(node.nodeType===1 && node.tagName==='H2')) {
                    const next = node.nextSibling;
                    content.appendChild(node.cloneNode(true));
                    node = next;
                }
                card.appendChild(content);
                container.appendChild(card);
            });

            // Enhance any tables for better mobile behavior
            applyTableEnhancements(container);
        }

        // Render wallpapers from markdown (expected format: optional title, intro paragraph(s), then image markdown lines or list items with alt text)
        function renderWallpapers(markdown) {
            const container = document.getElementById('wallpapers-content');
            if (!container) return;
            const html = marked.parse(markdown);
            const temp = document.createElement('div');
            temp.innerHTML = html;

            // Title
            let heading = temp.querySelector('h1, h2');
            const title = heading ? heading.textContent.trim() : 'Wallpapers';
            if (heading) heading.remove();

            // Collect intro nodes until first subsequent heading or gallery marker
            let introHTML = '';
            let node = temp.firstChild;
            while (node) {
                if (node.nodeType === 1 && /^(H1|H2|H3)$/.test(node.tagName)) break;
                // Stop if we encounter a figure or an img which indicates start of gallery
                if (node.nodeType === 1 && (node.tagName === 'IMG' || node.querySelector?.('img'))) break;
                const next = node.nextSibling;
                if (node.nodeType === 1 || (node.nodeType === 3 && node.textContent.trim())) {
                    introHTML += node.outerHTML || node.textContent;
                    node.remove();
                } else if (node.nodeType === 3 && !node.textContent.trim()) {
                    node.remove();
                }
                node = next;
            }

            // Build header card
            container.innerHTML = '';
            const headerCard = document.createElement('div');
            headerCard.className = 'signature-card signature-header-card';
            const h1 = document.createElement('h1');
            h1.textContent = title;
            headerCard.appendChild(h1);
            const overview = document.createElement('div');
            overview.className = 'signature-overview';
            overview.innerHTML = introHTML || '<p>Download community-themed wallpapers sized for phones and desktops. Tap or long-press to save.</p>';
            headerCard.appendChild(overview);
            container.appendChild(headerCard);

            // Prepare gallery with section filtering
            const galleryWrapper = document.createElement('div');
            galleryWrapper.className = 'wallpaper-gallery-wrapper';
            const filtersBar = document.createElement('div');
            filtersBar.className = 'wallpaper-filters';
            const gallery = document.createElement('div');
            gallery.className = 'wallpaper-grid';

            // Parse sections (H2/H3) and associate following images until next heading
            const sections = [];
            const contentNodes = Array.from(temp.childNodes);
            let currentSection = 'Misc';
            sections.push(currentSection);
            contentNodes.forEach(n => {
                if (n.nodeType === 1 && /^(H2|H3)$/.test(n.tagName)) {
                    currentSection = n.textContent.trim();
                    if (!sections.includes(currentSection)) sections.push(currentSection);
                    return; // move to next node
                }
                if (n.nodeType === 1) {
                    const imgs = n.tagName === 'IMG' ? [n] : Array.from(n.querySelectorAll('img'));
                    imgs.forEach(img => {
                        const src = img.getAttribute('src');
                        const alt = img.getAttribute('alt') || 'Wallpaper';
                        if (!src) return;
                        const item = document.createElement('div');
                        item.className = 'wallpaper-item';
                        item.dataset.section = currentSection;
                        item.innerHTML = `
                            <div class="wallpaper-thumb-wrapper">
                                <img src="${src}" alt="${alt}" loading="lazy" class="wallpaper-thumb" />
                                <button class="wallpaper-download" data-src="${src}" aria-label="Download ${alt}">‚¨áÔ∏è</button>
                            </div>
                            <div class="wallpaper-caption">${alt}</div>
                        `;
                        gallery.appendChild(item);
                    });
                }
            });

            if (!gallery.children.length) {
                const empty = document.createElement('div');
                empty.className = 'error';
                empty.innerHTML = 'No wallpapers found in <code>wallpapers.md</code>.';
                container.appendChild(empty);
                return;
            }

            // Build filter buttons
            const uniqueSections = sections.filter((s, i) => sections.indexOf(s) === i);
            const allBtn = document.createElement('button');
            allBtn.className = 'filter-btn active';
            allBtn.textContent = 'All';
            allBtn.dataset.section = '*';
            filtersBar.appendChild(allBtn);
            uniqueSections.forEach(sec => {
                // Skip creating a button for the default "Misc" catch-all section
                if (sec === 'Misc') return;
                const btn = document.createElement('button');
                btn.className = 'filter-btn';
                btn.textContent = sec;
                btn.dataset.section = sec;
                filtersBar.appendChild(btn);
            });

            filtersBar.addEventListener('click', e => {
                const btn = e.target.closest('.filter-btn');
                if (!btn) return;
                filtersBar.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const section = btn.dataset.section;
                gallery.querySelectorAll('.wallpaper-item').forEach(item => {
                    if (section === '*' || item.dataset.section === section) {
                        item.style.display = '';
                    } else {
                        item.style.display = 'none';
                    }
                });
            });

            galleryWrapper.appendChild(filtersBar);
            galleryWrapper.appendChild(gallery);
            container.appendChild(galleryWrapper);

            // Attach download handlers
            gallery.addEventListener('click', async (e) => {
                const btn = e.target.closest('.wallpaper-download');
                if (!btn) return;
                const url = btn.getAttribute('data-src');
                try {
                    const resp = await fetch(url);
                    const blob = await resp.blob();
                    const a = document.createElement('a');
                    const filename = url.split('/').pop() || 'wallpaper.png';
                    a.href = URL.createObjectURL(blob);
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
                } catch(err) {
                    console.error('Download failed', err);
                    alert('Download failed.');
                }
            });

            // Fullscreen preview modal setup (create once per page lifecycle)
            let modal = document.getElementById('wallpaper-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'wallpaper-modal';
                modal.setAttribute('role', 'dialog');
                modal.setAttribute('aria-modal', 'true');
                modal.innerHTML = `
                    <div class="wallpaper-modal-backdrop" data-close="true"></div>
                    <div class="wallpaper-modal-content">
                        <button class="wallpaper-modal-close" aria-label="Close preview" data-close="true">‚úï</button>
                        <img class="wallpaper-modal-img" alt="Wallpaper preview" />
                        <div class="wallpaper-modal-actions">
                            <button class="wallpaper-modal-download" aria-label="Download this wallpaper">Download</button>
                        </div>
                    </div>`;
                document.body.appendChild(modal);
                // Close handlers
                modal.addEventListener('click', (evt) => {
                    if (evt.target.dataset.close) {
                        modal.classList.remove('open');
                        document.body.classList.remove('no-scroll');
                    }
                });
                document.addEventListener('keydown', (evt) => {
                    if (evt.key === 'Escape' && modal.classList.contains('open')) {
                        modal.classList.remove('open');
                        document.body.classList.remove('no-scroll');
                    }
                });
                modal.querySelector('.wallpaper-modal-download').addEventListener('click', async () => {
                    const imgEl = modal.querySelector('.wallpaper-modal-img');
                    const url = imgEl.getAttribute('src');
                    try {
                        const resp = await fetch(url);
                        const blob = await resp.blob();
                        const a = document.createElement('a');
                        const filename = url.split('/').pop() || 'wallpaper.png';
                        a.href = URL.createObjectURL(blob);
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
                    } catch (err) {
                        console.error('Download failed', err);
                        alert('Download failed.');
                    }
                });
            }

            // Open modal when clicking on wallpaper thumbnail (but not download button)
            gallery.addEventListener('click', (e) => {
                const img = e.target.closest('img.wallpaper-thumb');
                // Ignore if download button was clicked (already handled above)
                if (!img || e.target.closest('.wallpaper-download')) return;
                const modalImg = modal.querySelector('.wallpaper-modal-img');
                modalImg.src = img.getAttribute('src');
                modal.classList.add('open');
                document.body.classList.add('no-scroll');
                // Focus close button for accessibility
                modal.querySelector('.wallpaper-modal-close').focus();
            });
        }
        // Render lead-up tab with header + overview similar to signature
        function renderLeadup(markdown) {
            const container = document.getElementById('leadup-content');
            if (!container) return;
            
            // Check if markdown is empty or whitespace only
            if (!markdown || !markdown.trim()) {
                hideLeadupTab();
                return;
            }
            
            showLeadupTab();
            const html = marked.parse(markdown);
            const temp = document.createElement('div');
            temp.innerHTML = html;
            // Find first heading (h1 or h2) for title
            const heading = temp.querySelector('h1, h2');
            const titleText = heading ? heading.textContent.trim() : 'Lead-Up Week';
            if (heading) heading.remove();
            // Collect initial paragraphs until next heading
            let overviewHTML = '';
            let node = temp.firstChild;
            while (node) {
                if (node.nodeType === 1 && /^(H1|H2|H3)$/.test(node.tagName)) break;
                const next = node.nextSibling;
                if (node.nodeType === 1 || (node.nodeType === 3 && node.textContent.trim())) {
                    overviewHTML += node.outerHTML || node.textContent;
                    node.remove();
                } else if (node.nodeType === 3 && !node.textContent.trim()) {
                    node.remove();
                }
                node = next;
            }
            container.innerHTML = '';
            const headerCard = document.createElement('div');
            headerCard.className = 'signature-card signature-header-card';
            const h1 = document.createElement('h1');
            h1.textContent = titleText;
            headerCard.appendChild(h1);
            const overview = document.createElement('div');
            overview.className = 'signature-overview';
            overview.innerHTML = overviewHTML || '<p>Countdown content leading into the main Signature Event. Includes spawns, raids, bonuses and preparation tips for the week.</p>';
            headerCard.appendChild(overview);
            container.appendChild(headerCard);
            const remainderWrapper = document.createElement('div');
            remainderWrapper.className = 'markdown-content';
            remainderWrapper.innerHTML = temp.innerHTML;
            container.appendChild(remainderWrapper);
            applyTableEnhancements(container);
        }

            
        function renderCampfire() {
            const container = document.getElementById('campfire-list');
            
            console.log('renderCampfire called, campfireData:', campfireData ? `${campfireData.length} chars` : 'null');
            
            if (!campfireData) {
                container.innerHTML = '<div class="error">No Campfire groups found. Please ensure campfire.md exists in your repository.</div>';
                return;
            }

            // Inject a header/description card once per load
            const tabRoot = document.getElementById('campfire-tab');
            if (tabRoot && !document.getElementById('campfire-header-card')) {
                const headerCard = document.createElement('div');
                headerCard.className = 'signature-card signature-header-card';
                headerCard.id = 'campfire-header-card';
                const titleEl = document.createElement('h1');
                titleEl.textContent = 'Campfire Groups';
                headerCard.appendChild(titleEl);
                const overview = document.createElement('div');
                overview.className = 'signature-overview';
                overview.innerHTML = '<p>Join local Pok√©mon GO communities on Campfire. Connect with nearby trainers, coordinate raids, and participate in group activities. Ambassador-led groups are officially recognized by Niantic.</p>';
                headerCard.appendChild(overview);
                tabRoot.insertBefore(headerCard, tabRoot.firstChild);
            }

            // Parse campfire markdown - format uses ### headers and bullet points
            const groups = [];
            const lines = campfireData.split('\n');
            console.log('Total lines in campfire.md:', lines.length);
            
            let currentGroup = null;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check for H3 header (### Group Name)
                const headerMatch = line.match(/^###\s+(.+)$/);
                if (headerMatch) {
                    if (currentGroup) {
                        groups.push(currentGroup);
                    }
                    // Support optional image markdown in the header line
                    let nameText = headerMatch[1].trim();
                    let logoFromHeader = null;
                    const headerImgMatch = nameText.match(/!\[[^\]]*\]\(([^)]+)\)/i); // allow relative or absolute
                    if (headerImgMatch) {
                        logoFromHeader = headerImgMatch[1].trim();
                        nameText = nameText.replace(/!\[[^\]]*\]\([^)]*\)/, '').trim();
                    }
                    currentGroup = {
                        name: nameText,
                        link: null,
                        ambassador: null,
                        logo: logoFromHeader
                    };
                    continue;
                }
                
                // Check for link in various formats:
                // Direct: [Join Group](url)
                // Bullet: - **Link:** [Join Group](url)
                const linkMatch = line.match(/\[Join Group\]\((.+?)\)/);
                if (linkMatch && currentGroup) {
                    currentGroup.link = linkMatch[1].trim();
                }

                // Check for ambassador led line: - **Ambassador Led:** ‚úÖ Yes or ‚ùå No
                const ambassadorMatch = line.match(/Ambassador\s+Led:\*\*\s*[‚úÖ‚ùå]?\s*(Yes|No)/i);
                if (ambassadorMatch && currentGroup) {
                    currentGroup.ambassador = ambassadorMatch[1].charAt(0).toUpperCase() + ambassadorMatch[1].slice(1).toLowerCase();
                }

                // Detect logo image: allow markdown image, HTML <img>, or a Logo: URL line
                if (currentGroup && !currentGroup.logo) {
                    // Markdown image
                    const imgMd = line.match(/!\[[^\]]*\]\(([^)]+)\)/i); // markdown image (relative or absolute)
                    if (imgMd) {
                        currentGroup.logo = imgMd[1].trim();
                        continue;
                    }
                    // HTML image
                    const imgHtml = line.match(/<img[^>]+src=["']([^"']+)["'][^>]*>/i);
                    if (imgHtml) {
                        currentGroup.logo = imgHtml[1].trim();
                        continue;
                    }
                    // Logo: URL (supports with or without ** and parentheses)
                    const logoLine = line.match(/logo\s*:?\s*\(?\s*([^\s)]+)\s*\)?/i); // Logo: path or URL
                    if (logoLine) {
                        currentGroup.logo = logoLine[1].trim();
                    }
                }
            }
            
            // Don't forget the last group
            if (currentGroup) {
                groups.push(currentGroup);
            }

            console.log('Parsed groups:', groups.length, groups);

            // Normalize relative logo paths: remove leading './' and auto-prefix folder when only a filename is given
            groups.forEach(g => {
                if (g.logo && !/^https?:\/\//i.test(g.logo)) {
                    let clean = g.logo.replace(/^\.\/+/, '').trim();
                    // If user provided just a filename (no slash), assume img/campfire directory
                    if (!clean.includes('/')) {
                        clean = 'img/campfire/' + clean;
                    }
                    g.logo = clean;
                }
            });

            // Sort: Ambassador Led Yes first, then No, then Unknown
            const sortedGroups = groups.slice().sort((a, b) => {
                const val = v => {
                    if (!v || typeof v !== 'string') return 2; // Unknown
                    const s = v.toLowerCase();
                    if (s === 'yes') return 0;
                    if (s === 'no') return 1;
                    return 2;
                };
                return val(a.ambassador) - val(b.ambassador);
            });

            // If nothing parsed, show a helpful message
            if (!sortedGroups.length) {
                console.error('No groups parsed from campfire.md');
                container.innerHTML = '<div class="error">No Campfire groups could be parsed. Please verify campfire.md uses the format: <strong>### Group Name</strong> on one line, a [Join Group](url) link, and \'- **Ambassador Led:** ‚úÖ Yes/‚ùå No\' line.</div>';
                return;
            }

            console.log('Rendering', sortedGroups.length, 'sorted groups');

            // Render groups as cards matching event card layout
            container.innerHTML = sortedGroups.map(group => {
                const ambassadorType = (() => {
                    if (!group.ambassador || typeof group.ambassador !== 'string') return 'campfire';
                    const val = group.ambassador.toLowerCase();
                    if (val === 'yes') return 'campfire verified';
                    if (val === 'no') return 'campfire unverified';
                    return 'campfire unknown';
                })();
                
                const ambassadorLabel = group.ambassador 
                    ? `Ambassador Led: ${group.ambassador}`
                    : 'Ambassador Status Unknown';
                
                const logoHTML = group.logo 
                    ? `<img class="campfire-logo" src="${group.logo}" alt="${group.name} logo" loading="lazy" referrerpolicy="no-referrer" onerror="this.replaceWith(Object.assign(document.createElement('div'),{className:'campfire-logo campfire-logo-fallback',textContent:'üî•'}));">`
                    : `<div class="campfire-logo campfire-logo-fallback">üî•</div>`;
                
                const joinButton = group.link ? 
                    `<a href="${group.link}" target="_blank" rel="noopener noreferrer" class="join-btn">üî• Join Group</a>` : 
                    '<span class="join-btn disabled">Link Not Available</span>';
                
                return `
                    <div class="event-card campfire-card">
                        <div class="campfire-header">
                            ${logoHTML}
                            <h3>${group.name}</h3>
                        </div>
                        <span class="event-type type-${ambassadorType}">${ambassadorLabel.toUpperCase()}</span>
                        <div class="campfire-actions">
                            ${joinButton}
                        </div>
                    </div>
                `;
            }).join('');

            // Enhance any tables for better mobile behavior
            applyTableEnhancements(container);
        }

        function renderLocations() {
            const listEl = document.getElementById('locations-list');
            const mapEl = document.getElementById('locations-map');
            if (!listEl || !mapEl) return;

            if (!locationsData || !locationsData.length) {
                listEl.innerHTML = '<div class="error">No locations found. Please ensure locations.md exists with entries like: <pre>### Name\n- Lat: 32.77\n- Lng: -96.79\n- Address: 123 Main St\n- Notes: Optional</pre></div>';
                mapEl.innerHTML = 'No locations to display yet.';
                return;
            }

            // Initialize map once Leaflet is available
            if (typeof L === 'undefined') {
                if (locationsRenderAttempts < 5) {
                    locationsRenderAttempts += 1;
                    setTimeout(renderLocations, 300);
                } else {
                    mapEl.innerHTML = 'Map failed to load (Leaflet unavailable).';
                }
                return;
            }
            if (!locationsMap) {
                locationsMap = L.map(mapEl, {
                    zoomControl: true,
                }).setView([32.7767, -96.7970], 9); // Default: Dallas area
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenStreetMap contributors'
                }).addTo(locationsMap);
            }
            if (locationsLayer) {
                locationsLayer.remove();
            }
            locationsLayer = L.layerGroup().addTo(locationsMap);

            const markers = [];
            locationsData.forEach(loc => {
                if (loc.lat != null && loc.lng != null) {
                    const marker = L.marker([loc.lat, loc.lng]);
                    const popupParts = [
                        `<strong>${loc.name}</strong>`,
                        loc.address ? `<div>${loc.address}</div>` : '',
                        loc.notes ? `<div style="margin-top:4px;">${loc.notes}</div>` : ''
                    ].filter(Boolean);
                    marker.bindPopup(popupParts.join(''));
                    marker.addTo(locationsLayer);
                    markers.push(marker);
                }
            });

            if (markers.length) {
                const group = L.featureGroup(markers);
                locationsMap.fitBounds(group.getBounds(), { padding: [30, 30] });
            } else {
                locationsMap.setView([32.7767, -96.7970], 9);
            }

            // Render list fallback
            listEl.innerHTML = locationsData.map(loc => {
                const coords = (loc.lat != null && loc.lng != null) ? `${loc.lat}, ${loc.lng}` : 'Coordinates not provided';
                return `
                    <div class="location-card">
                        <h3>${loc.name}</h3>
                        <p>${loc.address || loc.notes || ''}</p>
                        <p class="location-coords">${coords}</p>
                    </div>
                `;
            }).join('');
        }

        function showTab(tabName, tabLabel) {
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.style.display = 'none');
            
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(`${tabName}-tab`).style.display = 'block';
            
            // Find and activate the clicked button
            const clickedButton = Array.from(buttons).find(btn => 
                btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(tabName)
            );
            if (clickedButton) {
                clickedButton.classList.add('active');
            }

            // If locations tab is shown, (re)render and fix map sizing after becoming visible
            if (tabName === 'locations') {
                renderLocations();
                setTimeout(() => {
                    if (locationsMap) {
                        locationsMap.invalidateSize();
                        if (locationsLayer && locationsLayer.getLayers().length) {
                            try {
                                const group = L.featureGroup(locationsLayer.getLayers());
                                locationsMap.fitBounds(group.getBounds(), { padding: [30, 30] });
                            } catch (e) {
                                console.warn('Could not fit bounds for locations map', e);
                            }
                        }
                    }
                }, 200);
            }

            // Update mobile nav toggle text
            const mobileToggle = document.querySelector('.mobile-nav-toggle .current-tab');
            if (mobileToggle && tabLabel) {
                mobileToggle.textContent = tabLabel;
            }

            // Close mobile nav and menu after selection
            closeMobileNav();
            closeMobileMenu();
        }

        function toggleMobileNav() {
            const navTabs = document.getElementById('nav-tabs');
            navTabs.classList.toggle('mobile-open');
        }

        function closeMobileNav() {
            const navTabs = document.getElementById('nav-tabs');
            navTabs.classList.remove('mobile-open');
        }

        // Close mobile nav when clicking outside
        document.addEventListener('click', function(event) {
            const navContainer = document.querySelector('.nav-container');
            const navTabs = document.getElementById('nav-tabs');
            
            if (!navContainer.contains(event.target) && navTabs.classList.contains('mobile-open')) {
                closeMobileNav();
            }
        });

        // Pill navigation
        function navigateTabs(direction) {
            const navTabs = document.getElementById('nav-tabs');
            const visibleTabs = Array.from(navTabs.querySelectorAll('.tab-btn')).filter(
                tab => tab.style.display !== 'none'
            );
            
            if (visibleTabs.length <= 1) return;

            const currentIndex = visibleTabs.findIndex(tab => tab.classList.contains('active'));
            if (currentIndex === -1) return;

            let nextIndex;
            if (direction === 'next') {
                nextIndex = (currentIndex + 1) % visibleTabs.length;
            } else { // 'prev'
                nextIndex = (currentIndex - 1 + visibleTabs.length) % visibleTabs.length;
            }

            const nextTab = visibleTabs[nextIndex];
            if (nextTab) {
                nextTab.click(); // Simulate a click to trigger the showTab function
            }
        }

        // Toggle mobile menu
        function toggleMobileMenu() {
            const menu = document.getElementById('mobile-menu');
            const isOpen = menu.style.display === 'block';
            
            if (!isOpen) {
                // Populate menu with current tabs
                const navTabs = document.getElementById('nav-tabs');
                const visibleTabs = Array.from(navTabs.querySelectorAll('.tab-btn')).filter(
                    tab => tab.style.display !== 'none'
                );
                
                const menuTabsContainer = document.getElementById('mobile-menu-tabs');
                menuTabsContainer.innerHTML = visibleTabs.map(tab => {
                    const isActive = tab.classList.contains('active');
                    const tabText = tab.textContent.trim();
                    const onclickAttr = tab.getAttribute('onclick');
                    
                    return `<button class="mobile-menu-item ${isActive ? 'active' : ''}" onclick="${onclickAttr}; closeMobileMenu();">
                        ${tabText}
                    </button>`;
                }).join('');
                
                menu.style.display = 'block';
            } else {
                menu.style.display = 'none';
            }
        }

        function closeMobileMenu() {
            const menu = document.getElementById('mobile-menu');
            menu.style.display = 'none';
        }

        // Close mobile menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('mobile-menu');
            const menuBtn = document.getElementById('mobile-menu-btn');
            
            if (menu && menu.style.display === 'block' && 
                !menu.contains(event.target) && 
                !menuBtn.contains(event.target)) {
                closeMobileMenu();
            }
        });

        // Initialize - Load all markdown files
        async function init() {
            await loadContent();
        }

        // Initialize sticky mobile nav behavior
        function setupStickyMobileNav() {
            const navContainer = document.querySelector('.nav-container');
            if (!navContainer) return;

            let navTop = navContainer.getBoundingClientRect().top + window.scrollY;

            function updateNav() {
                // Only use sticky behavior on narrow viewports
                if (window.innerWidth > 768) {
                    navContainer.classList.remove('fixed');
                    document.body.classList.remove('nav-fixed');
                    document.body.style.removeProperty('--nav-height');
                    return;
                }

                const navHeight = navContainer.getBoundingClientRect().height;
                // Save nav height to a CSS variable so we can pad content
                document.body.style.setProperty('--nav-height', `${navHeight}px`);

                if (window.scrollY > navTop) {
                    if (!navContainer.classList.contains('fixed')) {
                        navContainer.classList.add('fixed');
                        document.body.classList.add('nav-fixed');
                    }
                } else {
                    if (navContainer.classList.contains('fixed')) {
                        navContainer.classList.remove('fixed');
                        document.body.classList.remove('nav-fixed');
                    }
                }
            }

            // Recalculate anchor position on resize/paint
            function recompute() {
                navTop = navContainer.getBoundingClientRect().top + window.scrollY;
                updateNav();
            }

            window.addEventListener('scroll', updateNav, { passive: true });
            window.addEventListener('resize', recompute);
            // run once to set initial state
            recompute();
        }

        // Dark Mode Toggle
        function initDarkMode() {
            const toggle = document.getElementById('dark-mode-toggle');
            if (!toggle) {
                console.error('Dark mode toggle button not found');
                return;
            }
            
            const toggleIcon = toggle.querySelector('.toggle-icon');
            if (!toggleIcon) {
                console.error('Toggle icon not found');
                return;
            }
            
            // Function to apply dark mode
            function applyDarkMode(isDark) {
                if (isDark) {
                    document.body.classList.add('dark-mode');
                    toggleIcon.textContent = '‚òÄÔ∏è';
                } else {
                    document.body.classList.remove('dark-mode');
                    toggleIcon.textContent = 'üåô';
                }
            }
            
            // Check for saved preference first, then system preference
            const savedMode = localStorage.getItem('dark-mode');
            
            if (savedMode === 'enabled' || savedMode === 'disabled') {
                // User has explicitly set a preference
                applyDarkMode(savedMode === 'enabled');
            } else {
                // No saved preference, check system preference
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                applyDarkMode(prefersDark);
            }
            
            // Listen for system preference changes
            const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            darkModeMediaQuery.addEventListener('change', (e) => {
                // Only auto-switch if user hasn't manually set a preference
                const savedMode = localStorage.getItem('dark-mode');
                if (savedMode !== 'enabled' && savedMode !== 'disabled') {
                    applyDarkMode(e.matches);
                }
            });
            
            // Toggle button click handler
            toggle.addEventListener('click', () => {
                document.body.classList.toggle('dark-mode');
                
                if (document.body.classList.contains('dark-mode')) {
                    toggleIcon.textContent = '‚òÄÔ∏è';
                    localStorage.setItem('dark-mode', 'enabled');
                } else {
                    toggleIcon.textContent = 'üåô';
                    localStorage.setItem('dark-mode', 'disabled');
                }
            });
        }

        // Ensure DOM is ready before updating tab label
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize dark mode first
            initDarkMode();
            
            async function updateLeadupTabLabelFromMarkdown() {
                const leadupMarkdown = await loadMarkdownFile('signature_leadup.md');
                let title = 'Lead-Up Week';
                let hasContent = leadupMarkdown && leadupMarkdown.trim();
                if (hasContent) {
                    // Try to extract H1 or first H2
                    const h1Match = leadupMarkdown.match(/^#\s+(.+)$/m);
                    const h2Match = leadupMarkdown.match(/^##\s+(.+)$/m);
                    if (h1Match) {
                        title = h1Match[1].trim();
                    } else if (h2Match) {
                        title = h2Match[1].trim();
                    }
                }
                const tabBtn = document.getElementById('leadup-tab-btn');
                if (tabBtn && hasContent) {
                    const displayTitle = title.length > 22 ? title.substring(0,19) + '‚Ä¶' : title;
                    tabBtn.innerHTML = `‚è≥ ${displayTitle}`;
                    tabBtn.setAttribute('onclick', `showTab('leadup', '‚è≥ ${displayTitle}')`);
                    // If leadup is active, update mobile nav
                    const mobileToggle = document.querySelector('.mobile-nav-toggle .current-tab');
                    if (mobileToggle && tabBtn.classList.contains('active')) {
                        mobileToggle.textContent = `‚è≥ ${displayTitle}`;
                    }
                    return `‚è≥ ${displayTitle}`;
                }
                return hasContent ? `‚è≥ ${title}` : null;
            }
            const leadupLabel = await updateLeadupTabLabelFromMarkdown();
            await init();
            setupStickyMobileNav();
            setupPullToRefresh();
            
            // Wait a tick for init() to finish loading signature data
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Prioritize showing Signature tab first if it exists
            const signatureBtn = document.getElementById('signature-tab-btn');
            const signatureBtnVisible = signatureBtn && signatureBtn.style.display !== 'none';
            
            if (signatureBtnVisible) {
                // Show signature tab with its actual event name
                const signatureLabel = signatureBtn.textContent.trim();
                showTab('signature', signatureLabel);
            } else if (leadupLabel) {
                // Fall back to leadup if signature is hidden
                showTab('leadup', leadupLabel);
            } else {
                // Last resort: show events tab
                showTab('events', 'üìÖ Pok√©mon Go Events');
            }
            
            // Ensure mobile nav shows the active tab text on load
            const mobileToggle = document.querySelector('.mobile-nav-toggle .current-tab');
            const activeBtn = document.querySelector('.tab-btn.active');
            if (mobileToggle && activeBtn) {
                mobileToggle.textContent = activeBtn.textContent.trim();
            }

            // Refresh data when returning to the tab after the interval
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    const now = Date.now();
                    if (now - lastDataRefresh > DATA_REFRESH_INTERVAL) {
                        await loadContent();
                    }
                }
            });
        });
        
        // Add to Home Screen functionality
        let deferredPrompt;
        const installBanner = document.getElementById('install-banner');
        const installButton = document.getElementById('install-button');
        const dismissButton = document.getElementById('install-dismiss');

        // Check if already installed or dismissed
        const isInstalled = localStorage.getItem('pwa-installed') === 'true';
        const isDismissed = localStorage.getItem('install-banner-dismissed') === 'true';

        // Listen for the beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the default browser install prompt
            e.preventDefault();
            deferredPrompt = e;
            
            // Show our custom banner if not dismissed and not installed
            if (!isInstalled && !isDismissed) {
                setTimeout(() => {
                    installBanner.style.display = 'block';
                    // Lift bottom UI above the banner
                    requestAnimationFrame(() => {
                        const h = installBanner.getBoundingClientRect().height || 0;
                        document.body.style.setProperty('--install-offset', (h + 12) + 'px');
                    });
                }, 3000); // Show after 3 seconds
            }
        });

        // Install button click handler
        if (installButton) {
            installButton.addEventListener('click', async () => {
                if (!deferredPrompt) {
                    return;
                }
                
                // Show the install prompt
                deferredPrompt.prompt();
                
                // Wait for the user's response
                const { outcome } = await deferredPrompt.userChoice;
                
                if (outcome === 'accepted') {
                    localStorage.setItem('pwa-installed', 'true');
                }
                
                // Clear the deferred prompt
                deferredPrompt = null;
                
                // Hide the banner and reset offsets
                installBanner.style.display = 'none';
                document.body.style.setProperty('--install-offset', '0px');
            });
        }

        // Dismiss button click handler
        if (dismissButton) {
            dismissButton.addEventListener('click', () => {
                installBanner.style.display = 'none';
                localStorage.setItem('install-banner-dismissed', 'true');
                
                // Auto-show again after 7 days
                setTimeout(() => {
                    localStorage.removeItem('install-banner-dismissed');
                }, 7 * 24 * 60 * 60 * 1000);
            });
        }

        // Detect if app was launched from home screen
        window.addEventListener('appinstalled', () => {
            localStorage.setItem('pwa-installed', 'true');
            installBanner.style.display = 'none';
            document.body.style.setProperty('--install-offset', '0px');
        });

        // For iOS Safari - show a different message since they don't support beforeinstallprompt
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isStandalone = window.navigator.standalone === true;
        
        if (isIOS && !isStandalone && !isDismissed) {
            setTimeout(() => {
                const iosBanner = document.getElementById('install-banner');
                const iosText = iosBanner.querySelector('.install-banner-text');
                iosText.innerHTML = `
                    <strong>üì± Install DFW PoGO</strong>
                    <p>Tap <span style="font-size: 1.2em;">‚éã</span> then "Add to Home Screen"</p>
                `;
                installButton.style.display = 'none'; // Hide install button on iOS
                iosBanner.style.display = 'block';
                requestAnimationFrame(() => {
                    const h = iosBanner.getBoundingClientRect().height || 0;
                    document.body.style.setProperty('--install-offset', (h + 12) + 'px');
                });
            }, 3000);
        }

        // Update offset when banner dismissed explicitly
        if (dismissButton) {
            dismissButton.addEventListener('click', () => {
                document.body.style.setProperty('--install-offset', '0px');
            });
        }

        // Mobile Pull-to-Refresh
        async function performRefresh() {
            // Remember active tab
            const activeBtn = document.querySelector('.tab-btn.active');
            let activeTabName = 'leadup';
            if (activeBtn) {
                const attr = activeBtn.getAttribute('onclick') || '';
                const m = attr.match(/showTab\('([^']+)'/);
                if (m) activeTabName = m[1];
            }
            await loadContent();
            // Restore the active tab and label
            const btnForTab = document.getElementById(`${activeTabName}-tab-btn`) || Array.from(document.querySelectorAll('.tab-btn')).find(b => (b.getAttribute('onclick')||'').includes(activeTabName));
            let label = btnForTab ? btnForTab.textContent.trim() : '';
            if (!label) {
                const fallback = { leadup: '‚è≥ Lead-Up Week', signature: 'üåü Signature Events', meetup: 'üìç Meetup Locations', events: 'üìÖ Pok√©mon Go Events', wallpapers: 'üñº Wallpapers' };
                label = fallback[activeTabName] || '';
            }
            showTab(activeTabName, label);
        }

        function setupPullToRefresh() {
            const ptr = document.getElementById('pull-to-refresh');
            if (!ptr) return;
            let startY = 0;
            let pulling = false;
            let distance = 0;
            const threshold = 70;
            const maxPull = 120;
            const icon = ptr.querySelector('.ptr-icon');
            const text = ptr.querySelector('.ptr-text');

            const isMobile = () => window.innerWidth <= 768;

            function onTouchStart(e) {
                if (!isMobile() || document.body.classList.contains('no-scroll')) return;
                if (window.scrollY > 0) return;
                startY = (e.touches ? e.touches[0].clientY : e.clientY) || 0;
                pulling = true;
                distance = 0;
            }

            function onTouchMove(e) {
                if (!pulling) return;
                const currentY = (e.touches ? e.touches[0].clientY : e.clientY) || 0;
                distance = Math.max(0, Math.min(maxPull, currentY - startY));
                if (distance > 0 && window.scrollY <= 0) {
                    // prevent native overscroll
                    e.preventDefault();
                    ptr.style.height = distance + 'px';
                    const rotate = Math.min(180, distance * 2);
                    icon.style.transform = `rotate(${rotate}deg)`;
                    text.textContent = distance > threshold ? 'Release to refresh' : 'Pull to refresh';
                } else {
                    onTouchEnd();
                }
            }

            async function onTouchEnd() {
                if (!pulling) return;
                pulling = false;
                if (distance > threshold) {
                    ptr.classList.add('refreshing');
                    ptr.style.height = '56px';
                    icon.style.transform = 'rotate(360deg)';
                    text.textContent = 'Refreshing‚Ä¶';
                    try {
                        await performRefresh();
                    } finally {
                        setTimeout(() => {
                            ptr.classList.remove('refreshing');
                            ptr.style.height = '0px';
                            icon.style.transform = '';
                            text.textContent = 'Pull to refresh';
                        }, 300);
                    }
                } else {
                    ptr.style.height = '0px';
                    icon.style.transform = '';
                }
            }

            window.addEventListener('touchstart', onTouchStart, { passive: true });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', onTouchEnd, { passive: true });
            window.addEventListener('touchcancel', onTouchEnd, { passive: true });
            window.addEventListener('resize', () => { ptr.style.height = '0px'; });
        }
    </script>
    <footer class="site-footer">
        <div class="container">
            <a class="discord-btn sticky" href="https://discord.gg/Yc6rg2a5xe" target="_blank" rel="noopener noreferrer" aria-label="Join our Discord server">Join our Discord Server</a>
        </div>
    </footer>

    <!-- Mobile Hamburger Menu Button -->
    <button class="mobile-menu-btn" id="mobile-menu-btn" onclick="toggleMobileMenu()" aria-label="Open navigation menu">
        <span class="hamburger-icon">‚ò∞</span>
    </button>

    <!-- Mobile Navigation Menu -->
    <div class="mobile-menu" id="mobile-menu" style="display: none;">
        <div class="mobile-menu-content">
            <div class="mobile-menu-header">Navigation</div>
            <div id="mobile-menu-tabs"></div>
            <a href="https://discord.gg/Yc6rg2a5xe" target="_blank" rel="noopener noreferrer" class="mobile-menu-discord">
                üéÆ Join Discord Server
            </a>
        </div>
    </div>

    <script>
        // Register service worker if supported
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('Service worker registered with scope:', reg.scope))
                .catch(err => console.warn('Service worker registration failed:', err));
        }
    </script>
</body>
</html>
