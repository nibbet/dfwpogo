<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFW Pokemon GO</title>
    <!-- PWA: manifest and theme color -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6E46A6">
    <link rel="apple-touch-icon" href="img/apple-touch-icon.png">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="DFW PoGO">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <link rel="stylesheet" href="css/styles.css">
    <script>
        // Use marked defaults and enable GFM + line breaks
        marked.setOptions({
            gfm: true,
            breaks: true
        });

        // No collapsible behavior â€” headers will be static purple sections
    </script>
</head>
<body>
    <div class="header">
        <h1>DFW PokÃ©mon Go</h1>
        <p>Your guide to local community events and Campfire groups</p>
    </div>

    <div class="container">
        <div class="nav-container">
            <button class="mobile-nav-toggle" onclick="toggleMobileNav()">
                <span class="current-tab">ðŸ“… Events</span>
                <span class="hamburger">â˜°</span>
            </button>
            <div class="nav-tabs" id="nav-tabs">
                <button class="tab-btn active" onclick="showTab('events', 'ðŸ“… PokÃ©mon Go Events')">ðŸ“… PokÃ©mon Go Events</button>
                <button id="signature-tab-btn" class="tab-btn" onclick="showTab('signature', 'ðŸŒŸ Signature Events')">ðŸŒŸ Signature Events</button>
                <button class="tab-btn" onclick="showTab('campfire', 'ðŸ”¥ Campfire Groups')">ðŸ”¥ Campfire Groups</button>
            </div>
        </div>

        <div class="content-area">
            <div id="events-tab" class="tab-content">
                <h2>Upcoming Events</h2>
                <div id="events-list" class="event-grid">
                    <div class="loading">Loading events...</div>
                </div>
            </div>

            <div id="signature-tab" class="tab-content" style="display:none;">
                <div id="signature-content" class="markdown-content">
                    <div class="loading">Loading signature event...</div>
                </div>
            </div>

            <div id="campfire-tab" class="tab-content" style="display:none;">
                <h2>Local Campfire Groups</h2>
                <div id="campfire-list">
                    <div class="loading">Loading Campfire groups...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // MAINTENANCE MODE - Change to true to enable
        // ==========================================
        const MAINTENANCE_MODE = false;
        
        let eventsData = [];
        let campfireData = '';
        let signatureData = '';
        let signatureTitle = localStorage.getItem('lastSignatureTitle') || 'Signature Events';

        // Constants for localStorage
        const STORAGE_KEYS = {
            TITLE: 'lastSignatureTitle',
            LAST_UPDATED: 'signatureTitleLastUpdated'
        };

        // Cache duration (24 hours in milliseconds)
        const CACHE_DURATION = 24 * 60 * 60 * 1000;

        // Load markdown files from GitHub
        async function loadMarkdownFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}`);
                }
                return await response.text();
            } catch (error) {
                console.error(`Error loading ${filename}:`, error);
                return null;
            }
        }

        // Parse events and filter out past events
        function parseEvents(markdown) {
            if (!markdown) return [];
            const events = [];
            const sections = markdown.split('##').filter(s => s.trim());
            const today = new Date();
            sections.forEach(section => {
                const lines = section.trim().split('\n');
                const title = lines[0].trim();
                const content = lines.slice(1).join('\n');
                const dateMatch = content.match(/\*\*Date:\*\*\s*(.+)/);
                const pokemonMatch = content.match(/\*\*Featured Pokemon:\*\*\s*(.+)/);
                const typeMatch = content.match(/\*\*Type:\*\*\s*(.+)/);
                const timeMatch = content.match(/\*\*Time\*\*\s*:?\s*(.+)/);
                let cleanContent = content
                    .replace(/\*\*Date:\*\*[^\n]*\n?/g, '')
                    .replace(/\*\*Featured Pokemon:\*\*[^\n]*\n?/g, '')
                    .replace(/\*\*Type:\*\*[^\n]*\n?/g, '')
                    .replace(/\*\*Time\*\*\s*:?.*\n?/g, '')
                    .trim();
                // Parse the date for filtering
                let eventDate = null;
                if (dateMatch) {
                    let dateStr = dateMatch[1].split(/[â€“-]/)[0].trim();
                    if (!/\d{4}/.test(dateStr) && /\d{4}/.test(dateMatch[1])) {
                        dateStr += ', ' + dateMatch[1].match(/\d{4}/)[0];
                    }
                    eventDate = new Date(dateStr);
                }
                let isUpcoming = true;
                if (eventDate instanceof Date && !isNaN(eventDate)) {
                    const eventDay = new Date(eventDate.getFullYear(), eventDate.getMonth(), eventDate.getDate());
                    const todayDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                    isUpcoming = eventDay >= todayDay;
                }
                if (isUpcoming) {
                    events.push({
                        title,
                        date: dateMatch ? dateMatch[1].trim() : 'TBA',
                        time: timeMatch ? timeMatch[1].trim() : '',
                        pokemon: pokemonMatch ? pokemonMatch[1].trim() : '',
                        type: typeMatch ? typeMatch[1].trim().toLowerCase().replace(/\s+/g, '-') : 'event',
                        content: marked.parse(cleanContent)
                    });
                }
            });
            return events;
        }

        function parseSignatureEvent(markdown) {
            if (!markdown || !markdown.trim()) {
                hideSignatureTab();
                return '';
            }
            
            // Extract title from first h1
            const titleMatch = markdown.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                const newTitle = titleMatch[1].trim();
                updateSignatureTitle(newTitle);
                showSignatureTab();
            } else {
                // Try to use cached title if available and not expired
                const cachedTitle = getCachedTitle();
                if (cachedTitle) {
                    signatureTitle = cachedTitle;
                    updateSignatureTabLabel();
                    showSignatureTab();
                } else {
                    hideSignatureTab();
                }
            }
            return marked.parse(markdown);
        }

        function updateSignatureTitle(newTitle) {
            signatureTitle = newTitle;
            // Cache the new title
            localStorage.setItem(STORAGE_KEYS.TITLE, newTitle);
            localStorage.setItem(STORAGE_KEYS.LAST_UPDATED, Date.now().toString());
            updateSignatureTabLabel();
        }

        function getCachedTitle() {
            const lastUpdated = parseInt(localStorage.getItem(STORAGE_KEYS.LAST_UPDATED) || '0');
            const cachedTitle = localStorage.getItem(STORAGE_KEYS.TITLE);
            
            // Check if cache exists and isn't expired
            if (cachedTitle && Date.now() - lastUpdated < CACHE_DURATION) {
                return cachedTitle;
            }
            
            // Clear expired cache
            localStorage.removeItem(STORAGE_KEYS.TITLE);
            localStorage.removeItem(STORAGE_KEYS.LAST_UPDATED);
            return null;
        }

        function updateSignatureTabLabel() {
            const tabBtn = document.getElementById('signature-tab-btn');
            if (!tabBtn) return;
            
            // Shorten title if it's too long
            const displayTitle = signatureTitle.length > 25 
                ? signatureTitle.substring(0, 22) + '...' 
                : signatureTitle;
            tabBtn.innerHTML = `ðŸŒŸ ${displayTitle}`;
            tabBtn.setAttribute('onclick', `showTab('signature', 'ðŸŒŸ ${displayTitle}')`);
        }

        function hideSignatureTab() {
            const tabBtn = document.getElementById('signature-tab-btn');
            if (tabBtn) {
                tabBtn.classList.add('hiding');
                // Wait for transition before hiding
                setTimeout(() => {
                    // If we previously moved the tab, attempt to restore its original position
                    const navTabs = document.getElementById('nav-tabs');
                    if (tabBtn.dataset && tabBtn.dataset.originalIndex) {
                        const originalIndex = parseInt(tabBtn.dataset.originalIndex, 10);
                        // If originalIndex is within bounds, insert before that child, otherwise append
                        if (!isNaN(originalIndex) && originalIndex < navTabs.children.length) {
                            navTabs.insertBefore(tabBtn, navTabs.children[originalIndex]);
                        } else {
                            navTabs.appendChild(tabBtn);
                        }
                        delete tabBtn.dataset.originalIndex;
                    }

                    tabBtn.style.display = 'none';
                    tabBtn.classList.remove('hiding');
                    // If signature tab was active, switch to events tab
                    if (tabBtn.classList.contains('active')) {
                        showTab('events', 'ðŸ“… Events');
                    }
                }, 300); // Match transition duration
            }
            const signatureTab = document.getElementById('signature-tab');
            if (signatureTab) {
                signatureTab.style.display = 'none';
            }
        }

        function showSignatureTab() {
            const tabBtn = document.getElementById('signature-tab-btn');
            if (tabBtn) {
                // Move the signature tab to the front when visible, remembering original position
                const navTabs = document.getElementById('nav-tabs');
                if (navTabs && !tabBtn.dataset.originalIndex) {
                    const children = Array.from(navTabs.children);
                    const idx = children.indexOf(tabBtn);
                    if (idx !== -1) tabBtn.dataset.originalIndex = idx;
                    navTabs.insertBefore(tabBtn, navTabs.firstChild);
                }

                // Reset visibility without transition
                tabBtn.classList.remove('hiding');
                tabBtn.style.opacity = '0';
                tabBtn.style.display = '';

                // Trigger transition
                requestAnimationFrame(() => {
                    tabBtn.style.opacity = '1';
                });
            }
        }

        function renderEvents() {
            const container = document.getElementById('events-list');
            
            if (eventsData.length === 0) {
                container.innerHTML = '<div class="error">No events found. Please ensure events.md exists in your repository.</div>';
                return;
            }
            
            container.innerHTML = eventsData.map(event => {
                // event.content comes pre-parsed (HTML) and metadata lines were removed in parseEvents
                const processedContent = event.content;
                const timeDisplay = event.time ? `<p><strong>ðŸ•’ ${event.time}</strong></p>` : '';

                return `
                <div class="event-card">
                    <span class="event-type type-${event.type}">${event.type.replace(/-/g, ' ').toUpperCase()}</span>
                    <h3>${event.title}</h3>
                    <p><strong>ðŸ“… ${event.date}</strong></p>
                    ${timeDisplay}
                    ${event.pokemon ? `<p><strong>âš¡ Featured: ${event.pokemon}</strong></p>` : ''}
                    <div class="markdown-content">${processedContent}</div>
                </div>
                `;
            }).join('');
        }

        function renderSignature() {
            const container = document.getElementById('signature-content');

            if (!signatureData) {
                container.innerHTML = '<div class="error">No signature event found. Please ensure signature.md exists in your repository.</div>';
                return;
            }

            // Parse the pre-rendered HTML from marked and reflow into a clearer structure
            const temp = document.createElement('div');
            temp.innerHTML = signatureData;

            // Extract title (first H1) and metadata paragraph (first P after H1)
            const h1 = temp.querySelector('h1');
            const titleText = h1 ? h1.textContent.trim() : '';

            let metaP = null;
            if (h1) {
                let sib = h1.nextElementSibling;
                while (sib && sib.tagName !== 'P') sib = sib.nextElementSibling;
                metaP = sib;
            } else {
                metaP = temp.querySelector('p');
            }

            const metaItems = [];
            if (metaP) {
                // split on <br> to preserve the labeled lines
                    const parts = metaP.innerHTML.split(/<br\s*\/?/i).map(s => s.trim()).filter(Boolean);
                    parts.forEach(p => {
                        const text = p.replace(/<[^>]+>/g, '').trim();
                        if (!text) return;
                        const idx = text.indexOf(':');
                        let key = '', value = '';
                        if (idx !== -1) {
                            key = text.slice(0, idx).trim();
                            value = text.slice(idx + 1).trim();
                        } else {
                            value = text;
                        }
                        metaItems.push({ key, value, raw: text });
                    });
                    metaP.remove();
            }

            if (h1) h1.remove();

            // Build card
            const card = document.createElement('div');
            card.className = 'signature-card';

            const header = document.createElement('div');
            header.className = 'signature-header';
            const titleEl = document.createElement('h1');
            titleEl.textContent = titleText || 'Signature Event';
            header.appendChild(titleEl);

            if (metaItems.length) {
                const metaDiv = document.createElement('div');
                metaDiv.className = 'signature-meta';
                    const iconFor = (k) => {
                        const key = (k || '').toLowerCase();
                        if (/date|dates/.test(key)) return 'ðŸ“…';
                        if (/time/.test(key)) return 'ðŸ•’';
                        if (/location|venue|where/.test(key)) return 'ðŸ“';
                        if (/ticket|tickets|rsvp|pass/.test(key)) return 'ðŸŽŸï¸';
                        if (/cost|price/.test(key)) return 'ðŸ’²';
                        return 'â„¹ï¸';
                    };
                    metaItems.forEach(mi => {
                        const span = document.createElement('span');
                        span.className = 'meta-item';
                        const icon = iconFor(mi.key);
                        const text = mi.value || mi.raw;
                        span.textContent = `${icon} ${text}`;
                        metaDiv.appendChild(span);
                    });
                header.appendChild(metaDiv);
            }

            card.appendChild(header);

            // Collect all H2 nodes to build sections
                const rawH2s = Array.from(temp.querySelectorAll('h2'));

                // Optional TL;DR summary â€” use the first paragraph BEFORE the first H2 (to avoid duplicating section content)
                let summaryPara = null;
                if (rawH2s.length) {
                    const firstH2 = rawH2s[0];
                    let n = temp.firstChild;
                    while (n && n !== firstH2) {
                        if (n.nodeType === 1 && n.tagName === 'P' && (n.textContent || '').trim()) {
                            summaryPara = n;
                            break;
                        }
                        n = n.nextSibling;
                    }
                }
                const tldr = summaryPara ? (summaryPara.textContent || '').split(/\.\s+/)[0] : '';

            // Build sections: for each H2, gather its following nodes until the next H2
            const allH2 = rawH2s; // reuse previously collected nodes
            if (allH2.length === 0) {
                // If no H2s, just append remaining content
                const intro = document.createElement('div');
                intro.className = 'signature-section';
                intro.innerHTML = temp.innerHTML;
                card.appendChild(intro);
            } else {
                // Add a TL;DR under the header if we have one
                if (tldr) {
                    const summ = document.createElement('div');
                    summ.className = 'signature-summary';
                    summ.textContent = tldr;
                    header.appendChild(summ);
                }

                allH2.forEach((h2) => {
                    const section = document.createElement('div');
                    section.className = 'signature-section';

                    // Add the section heading as a purple H2 above the box
                    const secHeading = document.createElement('h2');
                    secHeading.innerHTML = h2.innerHTML;
                    section.appendChild(secHeading);

                    // Create an event-like card box for this section's content
                    const box = document.createElement('div');
                    box.className = 'event-card';

                    // Gather nodes until next h2 into markdown-content inside the box
                    const md = document.createElement('div');
                    md.className = 'markdown-content';

                    let node = h2.nextSibling;
                    while (node && !(node.nodeType === 1 && node.tagName === 'H2')) {
                        const next = node.nextSibling;
                        md.appendChild(node.cloneNode(true));
                        node = next;
                    }

                    box.appendChild(md);
                    section.appendChild(box);
                    card.appendChild(section);
                });
            }

            container.innerHTML = '';
            container.appendChild(card);
        }

            
        function renderCampfire() {
            const container = document.getElementById('campfire-list');
            
            if (!campfireData) {
                container.innerHTML = '<div class="error">No Campfire groups found. Please ensure campfire.md exists in your repository.</div>';
                return;
            }

            // Parse campfire markdown - simple format with bold names and links
            const groups = [];
            const lines = campfireData.split('\n');
            
            let currentGroup = null;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check for bold group name (e.g., **Group Name**)
                const nameMatch = line.match(/^\*\*(.+?)\*\*$/);
                if (nameMatch) {
                    if (currentGroup) {
                        groups.push(currentGroup);
                    }
                    currentGroup = {
                        name: nameMatch[1].trim(),
                        link: null,
                        ambassador: null
                    };
                }
                
                // Check for link (e.g., [Join Group](url))
                const linkMatch = line.match(/\[Join Group\]\((.+?)\)/);
                if (linkMatch && currentGroup) {
                    currentGroup.link = linkMatch[1].trim();
                }

                // Check for ambassador led line (e.g., Ambassador Led: Yes/No)
                const ambassadorMatch = line.match(/^Ambassador\s+Led:\s*(Yes|No)\b/i);
                if (ambassadorMatch && currentGroup) {
                    currentGroup.ambassador = ambassadorMatch[1].charAt(0).toUpperCase() + ambassadorMatch[1].slice(1).toLowerCase();
                }
            }
            
            // Don't forget the last group
            if (currentGroup) {
                groups.push(currentGroup);
            }

            // Render groups as cards similar to events
            container.innerHTML = `
                <div class="event-grid">
                    ${groups.map(group => {
                        const joinButton = group.link ? 
                            `<a href="${group.link}" target="_blank" rel="noopener noreferrer" class="join-btn">ðŸ”¥ Join Group</a>` : 
                            '<span class="join-btn disabled">Link Not Available</span>';
                                                const ambassadorLine = typeof group.ambassador === 'string' && group.ambassador
                                                        ? (() => {
                                                                const val = (group.ambassador || '').toLowerCase();
                                                                const cls = val === 'yes' ? 'ambassador-yes' : (val === 'no' ? 'ambassador-no' : 'ambassador-unknown');
                                                                return `<div class=\"campfire-meta\"><span class=\"meta-item ambassador-badge ${cls}\">ðŸ‘¥ Ambassador Led: ${group.ambassador}</span></div>`;
                                                            })()
                                                        : '';
                        
                        return `
                            <div class="event-card campfire-card">
                                <h3>${group.name}</h3>
                                ${ambassadorLine}
                                <div class="campfire-actions">
                                    ${joinButton}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function showTab(tabName, tabLabel) {
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.style.display = 'none');
            
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(`${tabName}-tab`).style.display = 'block';
            
            // Find and activate the clicked button
            const clickedButton = Array.from(buttons).find(btn => 
                btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(tabName)
            );
            if (clickedButton) {
                clickedButton.classList.add('active');
            }

            // Update mobile nav toggle text
            const mobileToggle = document.querySelector('.mobile-nav-toggle .current-tab');
            if (mobileToggle && tabLabel) {
                mobileToggle.textContent = tabLabel;
            }

            // Close mobile nav after selection
            closeMobileNav();
        }

        function toggleMobileNav() {
            const navTabs = document.getElementById('nav-tabs');
            navTabs.classList.toggle('mobile-open');
        }

        function closeMobileNav() {
            const navTabs = document.getElementById('nav-tabs');
            navTabs.classList.remove('mobile-open');
        }

        // Close mobile nav when clicking outside
        document.addEventListener('click', function(event) {
            const navContainer = document.querySelector('.nav-container');
            const navTabs = document.getElementById('nav-tabs');
            
            if (!navContainer.contains(event.target) && navTabs.classList.contains('mobile-open')) {
                closeMobileNav();
            }
        });

        // Initialize - Load all markdown files
        async function init() {
            // Load events
            const eventsMarkdown = await loadMarkdownFile('events.md');
            if (eventsMarkdown) {
                eventsData = parseEvents(eventsMarkdown);
                renderEvents();
            } else {
                console.error('Failed to load events.md');
            }

            // Load signature event
            const signatureMarkdown = await loadMarkdownFile('signature.md');
            signatureData = parseSignatureEvent(signatureMarkdown || '');
            if (signatureData) {
                renderSignature();
            }

            // Load campfire groups
            const campfireMarkdown = await loadMarkdownFile('campfire.md');
            if (campfireMarkdown) {
                campfireData = campfireMarkdown;
                renderCampfire();
            }
        }

        // Load content when page loads
        // Initialize sticky mobile nav behavior
        function setupStickyMobileNav() {
            const navContainer = document.querySelector('.nav-container');
            if (!navContainer) return;

            let navTop = navContainer.getBoundingClientRect().top + window.scrollY;

            function updateNav() {
                // Only use sticky behavior on narrow viewports
                if (window.innerWidth > 768) {
                    navContainer.classList.remove('fixed');
                    document.body.classList.remove('nav-fixed');
                    document.body.style.removeProperty('--nav-height');
                    return;
                }

                const navHeight = navContainer.getBoundingClientRect().height;
                // Save nav height to a CSS variable so we can pad content
                document.body.style.setProperty('--nav-height', `${navHeight}px`);

                if (window.scrollY > navTop) {
                    if (!navContainer.classList.contains('fixed')) {
                        navContainer.classList.add('fixed');
                        document.body.classList.add('nav-fixed');
                    }
                } else {
                    if (navContainer.classList.contains('fixed')) {
                        navContainer.classList.remove('fixed');
                        document.body.classList.remove('nav-fixed');
                    }
                }
            }

            // Recalculate anchor position on resize/paint
            function recompute() {
                navTop = navContainer.getBoundingClientRect().top + window.scrollY;
                updateNav();
            }

            window.addEventListener('scroll', updateNav, { passive: true });
            window.addEventListener('resize', recompute);
            // run once to set initial state
            recompute();
        }

        init();
        setupStickyMobileNav();
    </script>
    <footer class="site-footer">
        <div class="container">
            <a class="discord-btn sticky" href="https://discord.gg/Yc6rg2a5xe" target="_blank" rel="noopener noreferrer" aria-label="Join our Discord server">Join our Discord Server</a>
        </div>
    </footer>
    <script>
        // Register service worker if supported
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('Service worker registered with scope:', reg.scope))
                .catch(err => console.warn('Service worker registration failed:', err));
        }
    </script>
</body>
</html>
